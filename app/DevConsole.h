//Generated by the Argon Build System

//
//  DevConsole.h
//  SDLTest
//
//  Created by Skyler Saleh on 1/2/14.
//  Copyright (c) 2014 Skyler Saleh. All rights reserved.
//

#ifndef SDLTest_DevConsole_h
#define SDLTest_DevConsole_h
#include <ArgonEngine/Hardware.h>
#include "ExplodingTeapots.h"
#include <ArgonEngine/Text.h>
#include <memory>
#include <vector>
#include <deque>
using namespace Argon;
struct UIWidget;
enum UIContextType{
    UIContextGroup,
    UIContextButton,
    UIContextLabel
};
struct UIRenderer{
    std::vector<Argon::Sprite> sprite_buffer;
    std::vector<Argon::Label> label_buffer;

};

struct UIContext{
    Node * parent=NULL;
    bool dragable_x=false;
    bool dragable_y=false;
    bool hovering=false;
    Vector2f origin=Vector2f(0,0);
    Vector2f size=Vector2f(0,0);
    bool needs_relayout=true;
    size_t update_id=0;

    std::deque<std::shared_ptr<Sprite>> sprite_cache;
    int sprite_index=0;
    void reset(){
        sprite_cache.resize(sprite_index);
        sprite_index=0;
        needs_relayout=true;
        for(auto s: sprite_cache){
            s->render_flags&=~kRenderShouldRender;
        }


    }


    void do_sprite(Argon::VirtualResource texture, Vector2f position, Vector2f size,int layer){
        while(sprite_cache.size()<=sprite_index){
            sprite_cache.push_back(std::make_shared<Argon::Sprite>());
        }
        Argon::Sprite & s =*sprite_cache[sprite_index++];
        s.position=Vector3f(position[0],position[1],0);
        s.dimensions=Vector3f(size[0],size[1],1.);
        s.anchor=Vector3f(0.5,0.5,0.);
        s.render_flags|=kRenderShouldRender;
        s.layer=layer;
        s.parent=parent;
        s.texture=texture;

    }

    void reset_per_layout(){
        sprite_cache.resize(sprite_index);
        sprite_index=0;
        ++update_id;
        for(auto s: sprite_cache){
            s->render_flags&=~kRenderShouldRender;
        }
    }
    bool should_layout(){
        bool b= needs_relayout;
        needs_relayout=false;

        if(b)reset_per_layout();

        return b;
    }


};

struct UILayout{
    UIContext* context=nullptr;
    UILayout* parent=nullptr;
    Vector2f position=Vector2f(0,0);
    Vector2f size=Vector2f(0,0);
    Vector2f content_size=Vector2f(0,0);
    Vector2f minimum_size=Vector2f(0,0);
    int layer=0;
    size_t update_id=0;
    Vector2f get_size(){
        Vector2f s=size;
        if(s[0]<0.)s[0]=content_size[0];
        if(s[1]<0.)s[1]=content_size[1];

        return max(minimum_size,s);
    }
    float right_off=0;
    float left_off=0;
    float top_off=0;
    float bottom_off=0;
    Vector2f minimum_content_size=Vector2f(0,0);
    int get_layer(){
        return parent? parent->get_layer()+layer:layer;
    }
    UILayout(){
        layer=1;
        context=NULL;
        position=Vector2f(0.,0.);
        size=Vector2f(-1, -1);
        content_size=Vector2f(-1,-1);
        minimum_size=Vector2f(0.,0.);
        parent=NULL;

    }

    void do_layout_base(UILayout& layout){
        if(&layout!=this)
        layout.parent=this;
        if(update_id!=context->update_id){
            minimum_content_size=minimum_size;
            update_id=context->update_id;
        }
        layout.context=context;
        Vector2f s = Vector2f(layout.right_off+layout.left_off,layout.top_off+layout.bottom_off);
        s=max(s,layout.minimum_content_size);
        if(s!=layout.content_size){
            context->needs_relayout=true;
            layout.content_size=s;
        }
        layout.right_off=layout.left_off=layout.top_off=layout.bottom_off=0;
    }
    void reset(){
        do_layout_base(*this);
    }
    UILayout& top(UILayout& layout){
        Vector2f s_t = get_size();
        layout.minimum_size=Vector2f(s_t[0]-right_off-left_off,0);
        do_layout_base(layout);

        Vector2f s = layout.get_size();
        top_off+=s[1];
        layout.position = position+Vector2f(left_off,s_t[1]-top_off);
        minimum_content_size=max(minimum_content_size,Vector2f(s+layout.position-position));
        return layout;
    }
    UILayout& bottom(UILayout& layout){
        do_layout_base(layout);
        layout.minimum_size=Vector2f(get_size()[0]-right_off-left_off,0);

        Vector2f s = layout.get_size();
        layout.position = position+Vector2f(left_off,bottom_off);
        bottom_off+=s[1];
        minimum_content_size=max(minimum_content_size,Vector2f(s+layout.position-position));
        return layout;
    }
    UILayout& left(UILayout&layout){
        Vector2f s_t = get_size();
        layout.minimum_size=Vector2f(0,s_t[1]-top_off-bottom_off);
        do_layout_base(layout);
        Vector2f s = layout.get_size();
        layout.position = position+Vector2f(left_off,s_t[1]-top_off-s[1]);
        left_off+=s[0];
        minimum_content_size=max(minimum_content_size,Vector2f(left_off,top_off+s[1]+bottom_off));
        return layout;
    }
    UILayout& right(UILayout& layout){
        Vector2f s_t = get_size();
        layout.minimum_size=Vector2f(0,s_t[1]-top_off-bottom_off);
        do_layout_base(layout);

        Vector2f s = layout.get_size();
        right_off+=s[0];
        layout.position = position+Vector2f(content_size[0]-right_off,s_t[1]-top_off-s[1]);
        minimum_content_size=max(minimum_content_size,Vector2f(minimum_size[0],top_off+s[1]+bottom_off));
        return layout;
    }
    UILayout* fill(VirtualResource texture){
        context->do_sprite(texture, position, get_size(),get_layer());
        return this;
    }
    UILayout* label(UILayout* layout,std::string & str);
    UILayout* check_box(UILayout* layout,bool& b);
};
struct UIWidget{
    virtual Vector2f get_content_size()=0;
    virtual void layout(UIContext & context)=0;
};
struct UINode{
    virtual float get_width(UIContext&c);
    virtual float get_height(UIContext&c);
};
struct TopBar{
    bool show_fps;
    bool show_devconsole;

    float play_speed;


};
struct DevConsole{
    TopBar top;

};
struct DevConsoleTest : public Argon::Node {
    Argon::Input input;

    Argon::VirtualResource font;
    float total_time=0;
    DevConsole console;
    UIContext context;
    UILayout main;
    UILayout top;
    UILayout right;
    UILayout bottom;
    UILayout top_right;
    UILayout top_right2;
    UILayout top_left;
    UILayout right_top;

    UILayout left;
    DevConsoleTest(){
        name="Developer Console";
        context.parent=this;
        main.context=&context;
        layer=10;
        font = "resource://times.ttf";

    }
    std::shared_ptr<Argon::Node> animate(float dt){
        total_time+=dt;
        //if(++x>30){x=0;
        //if(!context.should_layout()){
        //Argon::Screen::position.set(500+300*sin(total_time),300);
        context.reset();
        scale=Vector3f(20.,20.,20.)/Argon::Screen::size[1];
        position=Vector3f(-10./Argon::Screen::ratio(), -10.,0.);
        main.minimum_content_size=main.minimum_size=Argon::Screen::size;
        right.size[0]=Argon::Screen::size[0]/3.;
        bottom.size=Vector2f(40,40);
        left.size=Vector2f(20,20);
        top_right.size=Vector2f(64,56);
        top_right2.size=Vector2f(48,40);
        top_left.size=Vector2f(52,50);
        right_top.size=Vector2f(32,40);
        //}
        while(context.should_layout()){
            main.reset();
            main.top(top).fill("resource://test.png");
            top.right(top_right).fill("resource://metal.png");
            top.right(top_right2).fill("resource://metal.png");
            top.left(top_left).fill("resource://iris2.png");
            main.right(right).fill("resource://metal.png");
            main.bottom(bottom).fill("resource://test.png");
            main.left(left).fill("resource://test.png");
            right.top(right_top).fill("resource://iris2.png");
        }
        Argon::Sprite s;
        if(input[' '].value){
            return std::make_shared<ExplodingTeapots>();
        }
        return nullptr;
    }

};

#endif
