//Generated by the Argon Build System

//
//  Matrix2.h
//  ArgonEngine
//
//  Created by Skyler Saleh on 9/29/12.
//  Copyright (c) 2012 Argon Software. All rights reserved.
//

#ifndef ArgonEngine_Matrix2_h
#define ArgonEngine_Matrix2_h
using namespace Eigen;

#include "Vector.h"
namespace Argon {

typedef Eigen::Matrix4f Matrix4f;
typedef Eigen::Matrix<float,4,3> Matrix4x3f;
typedef Eigen::Matrix<float,4,2> Matrix4x2f;

typedef Eigen::Matrix<float,3,4> Matrix3x4f;
typedef Eigen::Matrix3f Matrix3f;
typedef Eigen::Matrix<float,3,2> Matrix3x2f;

typedef Eigen::Matrix<float,2,4> Matrix2x4f;
typedef Eigen::Matrix<float,2,3> Matrix2x3f;
typedef Eigen::Matrix2f Matrix2f;
template <class T,size_t size> using MatrixBase = Eigen::Matrix<T,size,size>;








template<typename T,typename T1,typename T2,typename T3>
static MatrixBase<T, 4> LookAtMatrix(const VectorBase<T1, 3>& eye_position, const VectorBase<T2, 3>& center,const VectorBase<T3, 3>& up){
    VectorBase<T,3> forward = normalize(center-eye_position);
    VectorBase<T,3> side = normalize(cross(forward, up));
    VectorBase<T,3> upv = cross(side, forward);
    MatrixBase<T, 4> m;
    m[0] = side[0];
    m[4] = side[1];
    m[8] = side[2];
    m[12] = 0.0;

    m[1] = upv[0];
    m[5] = upv[1];
    m[9] = upv[2];
    m[13] = 0.0;

    m[2] = -forward[0];
    m[6] = -forward[1];
    m[10] = -forward[2];
    m[14] = 0.0;

    m[3]=m[7]=m[11]=0.0;
    m[15]= 1.0f;
    return m*TranslateMatrix(eye_position* -1.0f);
}
template<typename T>
static MatrixBase<T, 4> FrustumMatrix(T left, T right, T bottom, T top,
                                      T znear, T zfar)
{

    T a = (right+left)/(right-left);
    T b = (top+bottom)/(top-bottom);
    T c = (zfar+znear)/(znear-zfar);
    T d = (2.0f*zfar*znear)/(znear-zfar);

    MatrixBase<T, 4> m;

    m.row(0)= Vector4f((2.0f*znear)/(right-left),0,0,0);

    m.row(1)=Vector4f(0,(2.0f*znear)/(top-bottom),0,0);
    m.row(2)=Vector4f(a,b,c,-1);
    m.row(3)=Vector4f(0,0,d,0);

    return m;
}
template<typename T>
static MatrixBase<T, 4> PerspectiveMatrix(T field_of_view,T aspect,T zNear, T zFar)
{
    T ymax, xmax;
    ymax = zNear * tanf(field_of_view* 3.14159f / 180.0f);

    xmax = ymax * aspect;

    return FrustumMatrix(-xmax, xmax, -ymax, ymax, zNear, zFar);
}

template<typename T>
static MatrixBase<T, 4> OrthoMatrix(T right, T left, T top, T bottom, T near, T far)
{
    MatrixBase<T, 4> matrix;
    matrix.row(0)= Vector4f(2.0f/(right-left),0.0f,0.0f,-((right+left)/(right-left)));
    matrix.row(1) = Vector4f( 0.0f, 2.0f/(top-bottom),0.0f,-((top+bottom)/(top-bottom)));
    matrix.row(2) = Vector4f(0.0f,0.0f,-2.0f/(far-near),-((far+near)/(far-near)));
    matrix.row(3) = Vector4f(0.0f,0.0f,0.0f,1.0f);
    return matrix;
}
template<typename T>
static INLINE MatrixBase<T, 3> mat3(const MatrixBase<T, 4>& m)
{
    return MatrixBase<T, 3>(m[0],m[1],m[2],m[4],m[5],m[6],m[8],m[9],m[10]);
}

};


#endif
