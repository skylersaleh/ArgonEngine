//Generated by the Argon Build System

//
//  VirtualResource.cpp
//  VirtualResource3
//
//  Created by Skyler Saleh on 8/20/13.
//  Copyright (c) 2013 Skyler Saleh. All rights reserved.
//

#include "VirtualResource.h"
#ifdef USE_CURL
#include <curl/curl.h>
#endif
#include "VirtualResourceImage.h"
#include <iostream>
#include "Reflection.h"
#include "Text.h"
#include <fstream>
#ifdef PLATFORM_UNIX
#include <sys/types.h>
#include <sys/stat.h>
#endif
#ifdef PLATFORM_WINDOWS
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#endif

namespace Argon{
struct VirtualResourceStringSource:public VirtualResourceIMPL::Source{
    VirtualResourceStringSource(const std::string &str):data(str){}
    std::string data;
    size_t size()const{return data.size();}
    size_t read(char* buffer, size_t buffer_size, size_t offset);
    void resize(size_t byte_size){data.resize(byte_size);}
    size_t write(const char* buffer, size_t buffer_size, size_t offset);
    virtual uint8_t* get_pointer(){return(uint8_t*)&data[0];}

    VirtualResourceIMPL::Source *create_source(const std::string& pa,const std::string& args){
        return new VirtualResourceStringSource(args);
    }

};
struct VirtualResourceAppended:public VirtualResourceIMPL::Source{
    std::vector<VirtualResource> resources;
    VirtualResourceAppended(const std::string &str);
    size_t size()const;
    size_t read(char* buffer, size_t buffer_size, size_t offset);
    void resize(size_t byte_size){}
    size_t write(const char* buffer, size_t buffer_size, size_t offset){
        return 0;
    }
    VirtualResourceIMPL::Source *create_source(const std::string& pa,const std::string& args){
        return new VirtualResourceAppended(args);
    }

};
#ifdef USE_CURL
    struct VirtualResourceCURL:public VirtualResourceIMPL::Source{
        VirtualResourceCURL(const std::string &str,bool allow_write=false):path(str),allow_write(allow_write){}
        Mutex loading;
        size_t update_id;
        std::string path;
        std::string data;
        double transfer_total;
        double transfer_current;
        bool allow_write;
        size_t write_offset;

        static size_t write_function(char *ptr, size_t size, size_t nmemb, void *resource);
        static size_t read_function(char *ptr, size_t size, size_t nmemb, void *resource);
        static int status_function(void *resource, double dltotal, double dlnow, double ultotal, double ulnow);

        bool reload();
        bool save();
        virtual uint8_t* get_pointer(){return(uint8_t*)&data[0];}
        size_t size()const{return data.size();}
        size_t read(char* buffer, size_t buffer_size, size_t offset);
        void resize(size_t byte_size){data.resize(byte_size);}
        size_t write(const char* buffer, size_t buffer_size, size_t offset);
        VirtualResourceIMPL::Source *create_source(const std::string& pa,const std::string& args);

    };
#endif
    namespace VirtualResourceIMPL{
        size_t search_string(const std::string &s, char character,size_t begin,size_t end){
            if(end==0)end=s.size();
            if(end==0)return 0;

            size_t i = begin;
            size_t brackets=0;
            if(character=='{')brackets--;
            while(i<end){
                if(s[i]=='{')brackets++;
                if(s[i]=='}')brackets--;
                if(s[i]==character&&!brackets)return i;
                ++i;

            }
            return end;
        }
        size_t advance_whitespace(const std::string &s,size_t begin,size_t end){
            if(end==0)end=s.size();
            if(end==0)return 0;
            size_t i =begin;
            while(i<end){
                char c = s[i];
                if(c !='\r' && c !='\t' && c != ' ' && c != '\n')return i;
                ++i;

            }
            return end;
        }
        size_t trim_whitespace(const std::string &s,size_t begin,size_t end){
            if(end==0)end=s.size();
            if(end==0)return 0;
            size_t i =end;
            while(i>begin){
                char c = s[i];
                if(c !='\r' && c !='\t' && c != ' ' && c != '\n')return i;
                --i;

            }
            return begin;
        }
        size_t parse_arguments(const std::string & s, std::string &args, size_t begin, size_t end){
            size_t i = advance_whitespace(s,begin,end);
            if(s[i]=='{'){
                ++i;
                size_t arg_end = search_string(s, '}',begin,end);
                args.assign(&s[i],arg_end-i);
                return trim_whitespace(s,arg_end,end);
            }
            return i;

        }
        size_t search_string_reverse(const std::string &s, char character,size_t begin,size_t end){
            if(end==0)end=s.size();
            if(end==0)return 0;

            size_t i = end-1;
            size_t brackets=0;
            if(character=='}')brackets--;

            while(i>begin){
                if(s[i]=='{')brackets--;
                if(s[i]=='}')brackets++;
                if(s[i]==character&&!brackets)return i;
                --i;

            }
            return begin;
        }
        void Pointer::remove_data(){
            if(data){
                if(source) data->save(source);
                delete data;
                data=NULL;
            }
        }
        void Pointer::remove_source(){
            if(source)source->save();
            delete source;
            source=NULL;
        }
        void Pointer::set_source(Source* s,bool reload){
            if(s!=source){
                remove_source();
                source=s;
                if(reload){
                    source->reload();
                    update_data();
                }
            }
        }

        size_t Pointer::update_id(){
            size_t i = 0;
            if(source)i+=source->update_id();
            if(data)i+=data->update_id();
            return i;

        }
        void Pointer::set_data(Data *d, bool reload){
            if(d!=data){
                remove_data();
                data=d;
                if(reload)update_data();
            }
        }


    };

    std::map<std::string,VirtualResourceIMPL::Pointer> &VirtualResource::all_nodes(){
        static std::map<std::string,VirtualResourceIMPL::Pointer> p;
        return p;
    }
    std::map<std::string,VirtualResourceIMPL::Source*> &VirtualResource::all_sources(){
        static std::map<std::string,VirtualResourceIMPL::Source*> p;
        return p;
    }
    std::map<std::string,VirtualResourceIMPL::Data*> &VirtualResource::all_data(){
        static std::map<std::string,VirtualResourceIMPL::Data*> p;
        return p;
    }

    void VirtualResource::remove(){
        if(p_node){
            p_node->users--;
            if(p_node->can_delete()){
                all_nodes().erase(get_pointer_iter());
            }
            p_node=NULL;
        }
    }
    void VirtualResource::set(VirtualResourceIMPL::Pointer *p){
        if(p_node!=p){
            remove();
            p_node=p;
            if(p_node)p_node->users++;
        }
    }

    void VirtualResource::set_source(const std::string &s,bool reload){
        size_t i = VirtualResourceIMPL::search_string(s, ':');

        std::string s2(&s[0],i+1);

        std::string args;
        i = VirtualResourceIMPL::parse_arguments(s, args, i+1, s.size());
        std::string path;
        int depth =0;
        while (i<s.size()) {
            if(s[i]=='{')depth++;
            if(depth<1){depth=0;path+=s[i];}
            if(s[i]=='}')depth--;
            ++i;
        }
        for(auto &c: s2)
            c = std::tolower(c);


        VirtualResourceIMPL::Source *sor = all_sources()[s2];
        if(sor){
            sor=sor->create_source(path,args);
        }else std::cout<<"Warning no source handler found for source: "<<s2<<" in path: "<<s<<"\n";


        p_node->set_source(sor, reload);
    }
    void VirtualResource::initialize(){
        VirtualResource::all_sources()["virtual:"]=
        VirtualResource::all_sources()["string:"]=new VirtualResourceStringSource("");
        VirtualResource::all_sources()["append:"]=new VirtualResourceAppended("");
        VirtualResource::all_sources()["file:"]=new VirtualResourceIO("/",true);

#ifdef USE_CURL

        VirtualResource::all_sources()["http:"]= new VirtualResourceCURL("http:/",false);
        VirtualResource::all_sources()["ftp:"]=  new VirtualResourceCURL("ftp:/",false);
        VirtualResource::all_sources()["sftp:"]= new VirtualResourceCURL("sftp:/",false);
        VirtualResource::all_sources()["pop3:"]= new VirtualResourceCURL("pop3:/",false);
        VirtualResource::all_sources()["imap:"]= new VirtualResourceCURL("imap:/",false);
        VirtualResource::all_sources()["smtp:"]= new VirtualResourceCURL("smtp:/",false);
        VirtualResource::all_sources()["scp:"]=  new VirtualResourceCURL("scp:/",false);
        VirtualResource::all_sources()["ldap:"]= new VirtualResourceCURL("ldap:/",false);

        VirtualResource::all_sources()["http-rw:"]= new VirtualResourceCURL("http:/",true);
        VirtualResource::all_sources()["ftp-rw:"]=  new VirtualResourceCURL("ftp:/",true);
        VirtualResource::all_sources()["sftp-rw:"]= new VirtualResourceCURL("sftp:/",true);
        VirtualResource::all_sources()["pop3-rw:"]= new VirtualResourceCURL("pop3:/",true);
        VirtualResource::all_sources()["imap-rw:"]= new VirtualResourceCURL("imap:/",true);
        VirtualResource::all_sources()["smtp-rw:"]= new VirtualResourceCURL("smtp:/",true);
        VirtualResource::all_sources()["scp-rw:"]=  new VirtualResourceCURL("scp:/",true);
        VirtualResource::all_sources()["ldap-rw:"]= new VirtualResourceCURL("ldap:/",true);
#endif

        VirtualResource::all_data()[".jpg"]=
        VirtualResource::all_data()[".jpeg"]=
        VirtualResource::all_data()[".png"]=
        VirtualResource::all_data()[".tga"]=
        VirtualResource::all_data()[".psd"]=
        VirtualResource::all_data()[".gif"]=
        VirtualResource::all_data()[".hdr"]=
        VirtualResource::all_data()[".pic"]=
        VirtualResource::all_data()[".tex"]=new VirtualResourceImage(0,0,kTextureRGB8);
        VirtualResource::all_data()[".json"]= new JsonResource;

        VirtualResource::all_data()[".ahf"]=new AHFResource;
    {
        std::cout<< "The Virtual Resource System has "<<VirtualResource::all_sources().size()<<" available sources to load from:\n";
        size_t max=0;
        for (auto &a : VirtualResource::all_sources()){
            if(max<a.first.size()+1)max=a.first.size()+1;
        }
        size_t indent = (max/4+1)*4;
        size_t pos =0;
        std::cout<<"|| ";
        for (auto &a : VirtualResource::all_sources()){
            if(pos>=80){
                std::cout<<"\n|| ";
                pos=0;
            }
            std::cout<<a.first;
            pos+=a.first.size();
            while((pos%indent)&&pos<80){
                std::cout<<" ";
                ++pos;
            }

        }
        std::cout<<"\n";

        }
        {
            std::cout<< "The Virtual Resource System has "<<VirtualResource::all_data().size()<<" known data types:\n";
            size_t max=0;
            for (auto &a : VirtualResource::all_data()){
                if(max<a.first.size()+1)max=a.first.size()+1;
            }
            size_t indent = (max/4+1)*4;
            size_t pos =0;
            std::cout<<"|| ";
            for (auto &a : VirtualResource::all_data()){
                if(pos>=80){
                    std::cout<<"\n|| ";
                    pos=0;
                }
                std::cout<<a.first;
                pos+=a.first.size();
                while((pos%indent)&&pos<80){
                    std::cout<<" ";
                    ++pos;
                }

            }
            }
        std::cout<<"\n";

        ReflectionBase::print_registered_factories();
    }

    void VirtualResource::set_data(const std::string &ext,bool reload){
        size_t i = VirtualResourceIMPL::search_string_reverse(ext, '.');
        if(i==0)return;
        size_t i2 = VirtualResourceIMPL::search_string(ext,'{',i,ext.size());
        std::string args;
        VirtualResourceIMPL::parse_arguments(ext, args, i2, ext.size());
        std::string extension(&ext[i],i2-i);
        for(auto &c: extension)
            c = std::tolower(c);
        VirtualResourceIMPL::Data *dat = all_data()[extension];
        if(dat)dat=dat->clone_type(args);
        p_node->set_data(dat, reload);
    }
    void VirtualResource::set(const std::string & path){
        auto it = path.begin();
        int depth = 0;
        while (it!=path.end()) {
            if(*it==':'&&depth==0)break;
            if(*it=='}')depth--;
            if(*it=='{')depth++;
            ++it;
        }
        while (it!=path.end()) {
            if(*it=='.'&&depth==0)break;
            if(*it=='}')depth--;
            if(*it=='{')depth++;
            ++it;
        }
        while (it!=path.end()) {
            if(*it=='{')break;
            ++it;
        }
        set(&all_nodes()[std::string(path.begin(),it)]);
        if(!p_node->source)set_source(path);
        if(!p_node->data)set_data(path);
    }
    size_t VirtualResource::update_id(){
        if(p_node)return p_node->update_id();
        return -1;
    }

    std::string VirtualResource::get_data_as_string(){
        std::string s;
        s.resize(size());
        read(&s[0], s.size(), 0);
        return s;
    }
    std::map<std::string,VirtualResourceIMPL::Pointer>::iterator
    VirtualResource::get_pointer_iter(){
        std::map<std::string,VirtualResourceIMPL::Pointer>::iterator it = all_nodes().begin();
        while (it!=all_nodes().end()) {
            if(&(it->second)==p_node)return it;
            ++it;
        }
        return all_nodes().end();
    }
    std::map<std::string,VirtualResourceIMPL::Pointer>::const_iterator
    VirtualResource::get_pointer_iter()const{
        std::map<std::string,VirtualResourceIMPL::Pointer>::const_iterator it = all_nodes().begin();
        while (it!=all_nodes().end()) {
            if(&(it->second)==p_node)return it;
            ++it;
        }
        return all_nodes().end();
    }


    size_t VirtualResourceStringSource::read(char* buffer, size_t buffer_size, size_t offset){
        if(offset>data.size())return 0;
        size_t read_end = offset+buffer_size;
        if(read_end>data.size())read_end=data.size();
        size_t read = read_end-offset;
        memcpy(buffer, &data[offset], read);
        return read;
    }
    size_t VirtualResourceStringSource::write(const char* buffer, size_t buffer_size, size_t offset){
        size_t write_end = offset+buffer_size;
        if(write_end>data.size())data.resize(write_end);
        memcpy(&data[offset], buffer, buffer_size);
        return 0;
    }

    VirtualResourceAppended::VirtualResourceAppended(const std::string &str){
        size_t i = 0;
        size_t end = str.size();
        while(i<end){
            size_t i2 = VirtualResourceIMPL::search_string(str, ',',i,end);
            i = VirtualResourceIMPL::advance_whitespace(str,i,i2);
            i2 = VirtualResourceIMPL::trim_whitespace(str,i,i2);

            std::string s(&str[i],i2-i);
            resources.push_back(s);
            i=i2+1;
        }

    }
    size_t VirtualResourceAppended::size()const{
        size_t val =0;
        std::vector<VirtualResource>::const_iterator it = resources.begin();
        while (it!=resources.end()) {
            val +=it->size();
            ++it;
        }
        return val;
    }
    size_t VirtualResourceAppended::read(char* buffer, size_t buffer_size, size_t offset){
        size_t b_off = 0;
        size_t val =offset;
        size_t end =offset+buffer_size;

        std::vector<VirtualResource>::iterator it = resources.begin();
        while (it!=resources.end()&&b_off!=buffer_size) {
            size_t next = it->size();
            if(next>end)next=end;
            if(next>val){
                it->read(buffer+b_off, next, val);
                b_off+=next;
            }else{
                val-=next;
            }
            end-=next;
            ++it;
        }

        return b_off;
    }

    bool VirtualResourceIO::save(){
        if(!allow_write)return false;
        std::fstream str(path.c_str(),(std::ios::in | std::ios::out|std::ios::binary|std::ios::trunc));
        str.write(&data[0],data.size());
        std::cout<<"Save "<<path<<std::endl;
        return true;
    }

    bool VirtualResourceIO::reload(){
        if(update_id()==update_id_)return true;

        std::fstream str(path.c_str(),allow_write?(std::ios::in | std::ios::out | std::ios::binary): std::ios::in|std::ios::binary);

        str.seekg(0,std::ios::end);
        std::streampos size = str.tellg();
        if(size==-1){
            data.resize(0);
            return false;
        }
        data.resize(size);
        update_id_=update_id();
        str.seekg(0,std::ios::beg);
        str.read(&data[0],size);
        return true;
    }
    size_t VirtualResourceIO::update_id(){
#ifdef PLATFORM_UNIX
        struct stat file_stats;
        if(stat(path.c_str(),&file_stats)==-1)return 0;
        return file_stats.st_mtime;
#endif

#ifdef PLATFORM_WINDOWS
        std::wstring filename;
        filename.assign(path.begin(),path.end());
        HANDLE file = CreateFile(filename.c_str(),GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

        if(file == INVALID_HANDLE_VALUE)
        {
            std::cerr << "\n\nERROR: File \"";
            std::cerr<< path;
            std::cerr << "\" not found when update_id called\n\n";
            CloseHandle(file);
            return 0;
        }

        else
        {
            FILETIME time;

            GetFileTime(file,NULL,NULL,&time);

            CloseHandle(file);

            size_t high = time.dwHighDateTime;
            size_t low = time.dwLowDateTime;

            high << sizeof time.dwHighDateTime;

            return high | low;
        }
#endif
        return 0;
    }

    size_t VirtualResourceIO::write(const char* buffer, size_t buffer_size,size_t offset){
        size_t begin = offset;
        size_t end = offset+buffer_size;
        if(end>data.size())data.resize(end);

        size_t size = end-begin;
        memcpy((void*)&data[begin],(const void*)buffer, size);
        return size;
    }
    size_t VirtualResourceIO::read(char* buffer, size_t buffer_size,size_t offset){

        size_t begin = offset;
        size_t end = offset+buffer_size;
        if(end>data.size())end = data.size();
        if(begin>=data.size())return 0;
        size_t size = end-begin;
        memcpy((void*)buffer, &data[begin], size);
        offset+=size;
        return size;
    }
    VirtualResourceIMPL::Source *VirtualResourceIO::create_source(const std::string& pa,const std::string& args){
        if(pa.size()>2){
            std::string s(&pa[1],pa.size()-1);
            return new VirtualResourceIO(path+s,allow_write);
        }
        return new VirtualResourceIO(path+pa,allow_write);
    }

#ifdef USE_CURL
    size_t VirtualResourceCURL::write_function(char *ptr, size_t size, size_t nmemb, void *resource){
        VirtualResourceCURL* source = (VirtualResourceCURL*)resource;
        size_t bs = size*nmemb;
        if(source->write_offset+bs>source->data.size()){
            bs = source->data.size()-source->write_offset;
        }
        memcpy(ptr, &source->data[source->write_offset], bs);
        source->write_offset+=bs;
        return bs;
    }
    size_t VirtualResourceCURL::read_function(char *ptr, size_t size, size_t nmemb, void *resource){
        VirtualResourceCURL* source = (VirtualResourceCURL*)resource;
        char* d_ptr = (char*)ptr;
        source->data.append(d_ptr, size*nmemb);
        return size*nmemb;
    }
    int VirtualResourceCURL::status_function(void *resource, double dltotal, double dlnow, double ultotal, double ulnow){
        VirtualResourceCURL* source = (VirtualResourceCURL*)resource;
        source->transfer_current=dlnow+ulnow;
        source->transfer_total=dltotal+dlnow;
        return 0;
    }
    bool VirtualResourceCURL::save(){
        if(!allow_write)return false;
        CURL *curl;
        write_offset =0;
        curl = curl_easy_init();

        if(curl) {
            curl_easy_setopt(curl, CURLOPT_URL, path.c_str());
            curl_easy_setopt(curl, CURLOPT_UPLOAD,1);
            curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,(curl_off_t)data.size());
            curl_easy_setopt(curl, CURLOPT_READFUNCTION, write_function);
            curl_easy_setopt(curl, CURLOPT_READDATA,this);
            curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, status_function);
            curl_easy_setopt(curl, CURLOPT_NOPROGRESS,0);
            curl_easy_setopt(curl, CURLOPT_PROGRESSDATA,this);
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,1);

            curl_easy_perform(curl);

            curl_easy_cleanup(curl);
        }
        return true;
    }

    bool VirtualResourceCURL::reload(){
        data.clear();
        CURL *curl;
        curl = curl_easy_init();
        if(curl) {
            curl_easy_setopt(curl, CURLOPT_URL, path.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_function);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA,this);
            curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, status_function);
            curl_easy_setopt(curl, CURLOPT_NOPROGRESS,0);
            curl_easy_setopt(curl, CURLOPT_PROGRESSDATA,this);
            curl_easy_perform(curl);
            curl_easy_cleanup(curl);
        }
        return true;
    }
    size_t VirtualResourceCURL::write(const char* buffer, size_t buffer_size,size_t offset){
        size_t begin = offset;
        size_t end = offset+buffer_size;
        if(end>data.size())data.resize(end);

        size_t size = end-begin;
        memcpy((void*)&data[begin],(const void*)buffer, size);
        return size;
    }
    size_t VirtualResourceCURL::read(char* buffer, size_t buffer_size,size_t offset){

        size_t begin = offset;
        size_t end = offset+buffer_size;
        if(end>data.size())end = data.size();
        if(begin>=data.size())return 0;
        size_t size = end-begin;
        memcpy((void*)buffer, &data[begin], size);
        offset+=size;
        return size;
    }
    VirtualResourceIMPL::Source *VirtualResourceCURL::create_source(const std::string& pa,const std::string& args){
        if(pa.size()>2){
            std::string s(&pa[1],pa.size()-1);
            return new VirtualResourceCURL(path+s,allow_write);
        }
        return new VirtualResourceCURL(path+pa,allow_write);
    }
#endif

    void get_argument_map(const std::string &args, std::map<std::string, std::string> &arg_map){
        int state=0;
        std::vector<std::string> arguments;
        std::string value;
        size_t i=0;
        while(i<args.size()){
            //initial
            if(state==0){
                arguments.clear();
                value.clear();
                if(!is_whitespace(args[i]))state=1;
                else ++i;
                //Arg Name
            }else if (state==1){
                if(args[i]==';'){
                    for(auto &a:arguments)arg_map[a]=value;
                    if(value.size()==0)
                        std::cout<< "Expected a value before character #"<<i+1<<"in "<<args<<"\n";
                    state=0;
                }
                else if(args[i]=='='){
                    arguments.push_back(value);
                    value="";
                }
                else if(!is_whitespace(args[i]))value+=args[i];
                ++i;
            }
        }
    }

};


