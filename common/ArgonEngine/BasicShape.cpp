//Generated by the Argon Build System

//
//  ARSprite.cpp
//  Neon Rush
//
//  Created by Skyler Saleh on 7/13/11.
//  Copyright 2011 Argon Software. All rights reserved.
//
//  Edited by Ian Wiggins on 11/23/14

#include "BasicShape.h"
#include <iostream>
#include "ContainerReflection.h"
namespace Argon
{

    BasicShape::BasicShape()
    {
        primitive=nullptr;
        model.reset(new MeshFormat);
        model->load_file("resource://basic-shapes.ahf");
        model->scale=Vector3f(0.5,0.5,0.5);
        model->parent=this;
    }
    BasicShape::~BasicShape(){
        primitive=nullptr;
    }

    void BasicShape::set_box(){
        primitive=model->spawn_object("Cube");
    }
    void BasicShape::set_sphere(){
        primitive=model->spawn_object("Sphere");

    }
    void BasicShape::set_torus(){
        primitive=model->spawn_object("Torus");

    }
    void BasicShape::set_cylinder(){
        primitive=model->spawn_object("Cylinder");
    }
    void BasicShape::set_plane(){
        primitive=model->spawn_object("Plane");

    }
    void BasicShape::set_ring(){
        primitive=model->spawn_object("Circle");
    }
    void BoundingCubeNode::set(const BoundingCube&c){
        position=c.origin;
        scale=c.size;
        bounds=c;
    }
    void BoundingCubeNode::initialize(){
        vertex_array = std::make_shared<VertexArray>();
        material = std::make_shared<Material>();
        vertex_array->draw_type=kDrawLines;
        vertex_array->add_attribute<float>(3, kPositionAttribute);

        vertex_array->set_size(8);
        VertexIterator pos_it = vertex_array->begin(kPositionAttribute);
        *(pos_it)  =Vector3f(0,0,0);
        *(++pos_it)=Vector3f(0,0,1);
        *(++pos_it)=Vector3f(0,1,0);
        *(++pos_it)=Vector3f(0,1,1);
        *(++pos_it)=Vector3f(1,0,0);
        *(++pos_it)=Vector3f(1,0,1);
        *(++pos_it)=Vector3f(1,1,0);
        *(++pos_it)=Vector3f(1,1,1);

        vertex_array->index_data.resize(24);
        //Left
        vertex_array->index_data[0]= 0;
        vertex_array->index_data[1]= 1;

        vertex_array->index_data[2]= 2;
        vertex_array->index_data[3]= 3;

        vertex_array->index_data[4]= 3;
        vertex_array->index_data[5]= 1;

        vertex_array->index_data[6]= 2;
        vertex_array->index_data[7]= 0;

        //Right
        vertex_array->index_data[8]= 4;
        vertex_array->index_data[9]= 5;

        vertex_array->index_data[10]= 6;
        vertex_array->index_data[11]= 7;

        vertex_array->index_data[12]= 5;
        vertex_array->index_data[13]= 7;

        vertex_array->index_data[14]= 6;
        vertex_array->index_data[15]= 4;

        //Wrap
        vertex_array->index_data[16]= 0;
        vertex_array->index_data[17]= 4;

        vertex_array->index_data[18]= 1;
        vertex_array->index_data[19]= 5;

        vertex_array->index_data[20]= 2;
        vertex_array->index_data[21]= 6;

        vertex_array->index_data[22]= 3;
        vertex_array->index_data[23]= 7;

        layer = kRenderLayerDebug;
        vertex_array->prim_size=2.;
        cull_face=kCullNone;
        render_flags&=~(kRenderDepthMask);


        material->shader="shader://debug.shd";

    }
    MAKE_VISIT_IMPL(BasicShape,{
                   ADD_BASE(Node);
                   ADD_VAR_T(primitive);
               });
    MAKE_VISIT_IMPL(BoundsRenderer, {
        ADD_VAR_T(color);
    });
    MAKE_VISIT_IMPL(BoundingCubeNode,{
                   ADD_BASE(Renderable);
               })


}
