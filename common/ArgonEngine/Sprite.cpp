//Generated by the Argon Build System

//
//  ARSprite.cpp
//  Neon Rush
//
//  Created by Skyler Saleh on 7/13/11.
//  Copyright 2011 Argon Software. All rights reserved.
//

#include "Sprite.h"
#include <iostream>
namespace Argon
{

    Sprite::Sprite()
    {
        texture="resource://test.png";

        material=std::make_shared<Argon::Material>();
        material->shader="shader://sprite_shader.shd";
        render_flags&=~(kRenderDepthMask);
        cull_face = kCullNone;
        bounds.origin=Vector3f(-0.5,-0.5,0.0);
        bounds.size=Vector3f(1,1,0);
        vertex_array=std::make_shared<VertexArray>();
        vertex_array->add_attribute<float>(2, "position");
        vertex_array->add_attribute<float>(2, "texture_coord");

        vertex_array->set_size(4);
        vertex_array->generate_indices();
        VertexIterator tex_it = vertex_array->begin("texture_coord");
        VertexIterator pos_it = vertex_array->begin("position");

        *(pos_it)  =Vector2f(-0.5,-0.5);
        *(++pos_it)=Vector2f(-0.5,0.5);
        *(++pos_it)=Vector2f(0.5,-0.5);
        *(++pos_it)=Vector2f(0.5,0.5);

        *(tex_it)  =Vector2f(0.0,1.0);
        *(++tex_it)=Vector2f(0.0,0.0);
        *(++tex_it)=Vector2f(1.0,1.0);
        *(++tex_it)=Vector2f(1.0,0.0);

        vertex_array->draw_type = kDrawTriangleStrip;
        vertex_array->update_id++;

    }

    void InstancedSprites::set_sprites(size_t total_sprites){
        int total_renders = total_sprites/kSpritesPerBatch+1;
        while(arrays.size()<total_renders){
            arrays.push_back(std::make_shared<VertexArray>());
            arrays.back()->add_attribute<float>(3,kPositionAttribute);
            arrays.back()->add_attribute<float>(4,kColorAttribute);
            arrays.back()->add_attribute<float>(2,kTextureAttribute);
            arrays.back()->draw_type=kDrawTriangles;
            arrays.back()->updates_frequently=true;
            arrays.back()->recalc_stride();
        }
        if(arrays.size()!=total_renders){ arrays.resize(total_renders);}

        while(renders.size()<total_renders){
            renders.push_back(std::make_shared<Renderable>());
            std::shared_ptr<Renderable> &render = renders.back();
            render->material=material;
            render->cull_face = kCullNone;
            render->parent=this;
            render->vertex_array=arrays[renders.size()-1];
        }
        if(renders.size()!=total_renders) renders.resize(total_renders);
        size_t size_r=total_sprites;
        int index=0;
        while(size_r>=kSpritesPerBatch){
            if(arrays[index]->vertex_count() !=kVerticesPerBatch){
                arrays[index]->set_size(kVerticesPerBatch);
                arrays[index]->generate_indices_quad();

            }
            size_r-=kSpritesPerBatch;
            index++;


        }

        if(arrays.back()->vertex_count()!=size_r*4){
            arrays.back()->set_size(size_r*4);
            arrays[index]->generate_indices_quad();

        }
    }


    void InstancedSprites::set_sprite(size_t index,const Vector4f& color,const Vector3f& v0,const Vector3f& v1,const Vector3f& v2,const Vector3f& v3 ,const Vector2f &min_tex,const Vector2f& max_tex){
        VertexArray &it = *arrays[index>>14ul];
        float* d = ((float*)it.data_start())+(index&kSpritesMask)*36;

        d[0]= v0[0];
        d[1]= v0[1];
        d[2]= v0[2];

        d[3]= color[0];
        d[4]= color[1];
        d[5]= color[2];
        d[6]= color[3];

        d[7]=min_tex[0];
        d[8]=min_tex[1];

        d[9]= v1[0];
        d[10]= v1[1];
        d[11]= v1[2];

        d[12]= color[0];
        d[13]= color[1];
        d[14]= color[2];
        d[15]= color[3];

        d[16]=min_tex[0];
        d[17]=max_tex[1];

        d[18]= v2[0];
        d[19]= v2[1];
        d[20]= v2[2];

        d[21]= color[0];
        d[22]= color[1];
        d[23]= color[2];
        d[24]= color[3];

        d[25]=max_tex[0];
        d[26]=min_tex[1];

        d[27]= v3[0];
        d[28]= v3[1];
        d[29]= v3[2];

        d[30]= color[0];
        d[31]= color[1];
        d[32]= color[2];
        d[33]= color[3];

        d[34]=max_tex[0];
        d[35]=max_tex[1];


        it.update_id++;
    }
    void InstancedSprites::set_sprite(size_t index, const Vector4f& color,const Vector3f scale,const Vector3f position,const Quaternionf &rotation,Vector2f min_tex,Vector2f max_tex){
        Vector3f v0(-0.5f*scale[0],0.5f*scale[1],0.f);
        const Vector3f v1 = rotation.transform(v0);
        v0[0]*=-1.f;
        const Vector3f v2 = rotation.transform(v0);

        set_sprite(index,color,position+v1,
                   position-v2,
                   position+v2,
                   position-v1,min_tex,max_tex);

    }


    void InstancedSprites::set_transform(size_t index, Node & transform,Vector2f min_tex, Vector2f max_tex){
        if(transform.get_should_render()){
            Matrix4f world_matrix = transform.world_matrix();
            Vector4f pos[4]= {Vector4f(-0.5,0.5,0,1),Vector4f(-0.5,-0.5,0,1),Vector4f(0.5,0.5,0,1),Vector4f(0.5,-0.5,0,1)};
            pos[0]=world_matrix*pos[0];
            pos[1]=world_matrix*pos[1];
            pos[2]=world_matrix*pos[2];
            pos[3]=world_matrix*pos[3];

            set_sprite(index,transform.get_color(),Vector3f(pos[0]/pos[0][3]),
                    Vector3f(pos[1]/pos[1][3]),
                    Vector3f(pos[2]/pos[2][3]),
                    Vector3f(pos[3]/pos[3][3]),min_tex,max_tex);
        }else{
            set_sprite(index,Vector4f(0,0,0,0),Vector3f(),Vector3f(),Vector3f(),Vector3f(),min_tex,max_tex);
        }

    }
    MAKE_VISIT_IMPL(Sprite,{
                   ADD_BASE(Renderable);
               })


}
