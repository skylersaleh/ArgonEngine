//Generated by the Argon Build System

#include "AudioSystem.h"
#include <iostream>
#include "ContainerReflection.h"
#include "Vector.h"
namespace Argon{
AudioSource3D* AudioSource3D::root_source=NULL;
std::shared_ptr<AudioNode> AudioNode::root_nodes[kAudioNumberOfChannels];
size_t         Listener::current_frame=0;

void SinGenerator::render(float* buffer){
    float *be = buffer+kAudioBufferSize;
    while(buffer!=be){
        *buffer++ += phase*volume;
        phase+=frequency*kAudioTimePerSample;
        if(phase>1.)phase-=2.0;

    }
}
void SawGenerator::render(float * buffer){
    float *be = buffer+kAudioBufferSize;
    while(buffer!=be){
        *buffer++ += phase*volume;
        phase+=frequency*kAudioTimePerSample*2.;

        if(phase>1.)phase=-1;


    }
}
void TriangleGenerator::render(float * buffer){
    float *be = buffer+kAudioBufferSize;
    while(buffer!=be){
        *buffer++ += phase*volume;
        phase+=frequency*kAudioTimePerSample*direction*2.;

        if(phase>1.)direction=-1;
        if(phase<-1.)direction=1;


    }
}

void Mixer::render(float * buffer){
    for (size_t i = 0; i<channels.size(); ++i) {
        channels[i]->render(buffer);
    }
}
void Repeater::clone::render(float * buffer){
    if(!in_buffer)return;
    float * buff_end = buffer+kAudioBufferSize;
    float * tb= in_buffer;
    while(buffer!=buff_end){
        (*buffer++)+=(*tb++)*volume;
    }
}
void Repeater::render(float * buffer){
    if(!input)return;
    float *tb= in_buff;
    float *tbe = tb+kAudioBufferSize;
    while(tb!=tbe){(*tb++)=0.f;}
    input->render(in_buff);
    tb=in_buff;
    while(tb!=tbe)(*buffer++)+=*tb++;
}
std::shared_ptr<AudioNode> Repeater::get_clone(size_t i){
    std::shared_ptr<Repeater::clone> n = cloned_outputs[i];
    n->in_buffer= in_buff;
    return n;
}
void Resample::render(float * buffer){
    if(!input||volume<kMinVolume)return;
    float * be = buffer+kAudioBufferSize;
    while(buffer!=be){

        if(sample_pos>=kAudioBufferSize){
            last = sample_buffer[kAudioBufferSize-1];

            float *sb = sample_buffer;
            float *sbe = sb+kAudioBufferSize;
            while(sb!=sbe)(*sb++)=0.0;
            sample_pos -=kAudioBufferSize;
            input->render(sample_buffer);
        }
        int index = sample_pos;
        float v= interopolate(index?sample_buffer[index-1]:last,sample_buffer[index],sample_pos-index);
        low_pass = low_pass*0.3+v*0.7;
        (*buffer++)+=low_pass;
        sample_pos+=rate;
    }
}
void OggNode::Clone::render(float* buffer){
    if(volume<kMinVolume||!parent->initialized)return;
    float *be = buffer+kAudioBufferSize;
    while(buffer!=be){
        while(data.empty()){
            parent->read_data();
        }
        (*buffer++)+=data.front()*volume;
        data.pop_front();
    }
}
void OggNode::read_data(){
    if(!opus_file&&!vorbis_file){
        for(size_t i = 0;i<4096;++i){

            clones[0]->data.push_back(0);
            clones[0]->data.push_back(0);
        }
        return;
    }
    size_t size=0;
    if(opus_file){
        int64_t pos =op_pcm_tell(opus_file);
        int64_t total=op_pcm_total(opus_file,-2);
        if(std::abs(playback_position-(float(pos)/float(total)))>0.0005){
            op_pcm_seek(opus_file,playback_position*total);
            pos =op_pcm_tell(opus_file);
        }
        size=op_read_float_stereo(opus_file,PCM_data,std::min(total-pos ,int64_t(4096)));
        pos =op_pcm_tell(opus_file);
        playback_position = float(pos)/float(total);
        if(pos+size>=total-2&&loop){
            playback_position=0;
            op_pcm_seek(opus_file,0);
        }
        for(size_t i = 0;i<size;++i){

            clones[0]->data.push_back(PCM_data[i*2]);
            clones[1]->data.push_back(PCM_data[i*2+1]);
        }
    }else if(vorbis_file){
        int64_t pos =ov_pcm_tell(vorbis_file);
        int64_t total=ov_pcm_total(vorbis_file,-2);
        if(std::abs(playback_position-(float(pos)/float(total)))>0.0005){
            ov_pcm_seek(vorbis_file,playback_position*total);
            pos =ov_pcm_tell(vorbis_file);
        }
        float**buffer;
        int stream=0;
        long size=ov_read_float(vorbis_file,&buffer,4096,&stream);

        pos =ov_pcm_tell(vorbis_file);
        playback_position = float(pos)/float(total);
        if(pos+size>=total-2&&loop){
            playback_position=0;
            ov_pcm_seek(vorbis_file,0);
        }
        vorbis_info *v =ov_info(vorbis_file,stream);
        for(int c = 0;c<8&&c<v->channels;++c){
            if(c<=number_of_channels){
                for(size_t i = 0;i<size;++i){
                    clones[c]->data.push_back(buffer[c][i]);
                }
                channels[c]->rate = double(v->rate)/double(kAudioSampleRate);
            }else{
                int c2 = number_of_channels;
                c2-=1;
                for(size_t i = 0;i<size;++i){
                    clones[c2]->data.push_back(buffer[c][i]);
                }
                channels[c2]->rate = double(v->rate)/double(kAudioSampleRate);

            }
        }
    }


}

AudioSource3D::AudioSource3D(){
    prev_source=NULL;
    next_source=root_source;
    for(size_t i=0;i<kAudioBufferSize;++i){
        audio_data[i]=0;
    }
    root_source=this;
}
AudioSource3D::~AudioSource3D(){
    if(prev_source)
        prev_source->next_source=next_source;
    if(next_source)next_source->prev_source=prev_source;
    if(root_source==this)root_source=next_source;
}
void AudioSource3D::update_if_needed(size_t current_frame){
    if(input&&last_frame!=current_frame){
        last_frame=current_frame;
        for(size_t i = 0;i<kAudioBufferSize;++i)audio_data[i]=0;
        input->render(audio_data);
    }
}
void AudioSource3D::finalize_data(){
    last_position2 = last_position;

    last_position=last_position*0.9+position*0.1;
}
void PeakDetector::render(float *buffer){
    input->render(buffer);
    //peak-=peak_decay+peak*peak_decay_exp;
    float max=-1000;
    float min=1000;
    for(int i=0;i<kAudioBufferSize;++i){
        float v = buffer[i];
        if(max<v)max=v;
        if(min>v)min=v;
    }
    if(max!=max||min!=min)max=min=0;
    float p = (max-min)*10.;

    peak = p*decay_coeff+peak*(1.-decay_coeff);
    if(peak<p)  peak = peak*(1.0-growth_coeff)+p*growth_coeff;

}

void Listener::update(){
    AudioSource3D* curr = AudioSource3D::root_source;

    while(curr){

        Vector3f last_direction = (curr->last_position2-last_position).normalized();
        Vector3f curr_direction = (curr->last_position-position).normalized();


        float last_direction_scale = (direction.dot(last_direction)+1.0)*direction_factor+1.0-direction_factor;
        float curr_direction_scale = (direction.dot(curr_direction)+1.0)*direction_factor+1.0-direction_factor;
        float direction_incr = (curr_direction_scale-last_direction_scale)/float(kAudioBufferSize);

        float previous_distance = distance(curr->last_position2,last_position);
        float curr_distance = distance(curr->last_position,position);
        float increment = (curr_distance-previous_distance)/float(kAudioBufferSize);

        int last_offset = sample_delay_for_distance(previous_distance);
        int curr_offset = sample_delay_for_distance(curr_distance);
        float offset_incr = float(kAudioBufferSize)/(curr_offset-last_offset+kAudioBufferSize);

        //std::cout<<offset_incr<<" "<<this<<"\n";


        curr->update_if_needed(current_frame);
        //std::cout<<last_offset<<" "<<curr_offset<<" "<<offset_incr<<"\n";

        int x=0;
        while(x<curr_offset-last_offset+kAudioBufferSize){


            Argon::RollingInt<0,kAudioListenerBufferSamples-1> ind;
            /*while (x<kAudioBufferSize && ind==index1) {

                    index2 = index1+1;
                    float ratio = curr_sample+0.5-int(curr_sample+0.5f);

                    x1+=curr->audio_data[x]*v;;
                   // x2+=curr->audio_data[x]*ratio*v;;
                    ++x;
                    curr_sample=int(delay_index)+x*offset_incr;
                    previous_distance+=increment;
                    last_direction_scale+=direction_incr;
                    ++count;
                    index1 = curr_sample+0.5;


                }*/
            float inten = intensity_at_distance(previous_distance+x*increment)*(last_direction_scale+direction_incr*x);

            int v = offset_incr*x+0.5;
            if(v>=kAudioBufferSize)v=kAudioBufferSize-1;
            ind = x + last_offset+delay_index;
            delay_buffer[ind]+=curr->audio_data[v]*inten;

            x++;

        }
        curr=curr->next_source;
    }
    last_position=position;
}
void Listener::render(float * buffer){
    if(volume<kMinVolume)return;
    update();
    float * be = buffer+kAudioBufferSize;
    if(low_pass!=low_pass)low_pass = 0.;
    while(buffer!=be){
        float v= delay_buffer[delay_index];
        low_pass = v*0.7+low_pass*0.3;
        (*buffer++)+=low_pass;
        delay_buffer[delay_index]=0.0;
        ++delay_index;
    }

}

Listener::Listener(){
    direction_factor =1.0;
    low_pass=0;
    speed_of_sound=340.29;//meters per second @ sea level.
    for(int i=0;i<kAudioListenerBufferSamples;++i){
        delay_buffer[i]=0.;

    }
}

MAKE_VISIT_IMPL(SinGenerator,{
        ADD_VAR(phase);
        ADD_VAR(frequency);
        ADD_BASE(AudioNode);
        v.finish_map();
    })
MAKE_VISIT_IMPL(SawGenerator,{
        ADD_VAR(phase);
        ADD_VAR(frequency);
        ADD_BASE(AudioNode);
        v.finish_map();
    })
MAKE_VISIT_IMPL(TriangleGenerator,{
        ADD_VAR(phase);
        ADD_VAR(frequency);
        ADD_VAR(direction);
        ADD_BASE(AudioNode);
        v.finish_map();
    })
MAKE_VISIT_IMPL(Mixer,{
               ADD_VAR(channels);
               ADD_BASE(AudioNode);
           })
MAKE_VISIT_IMPL(PeakDetector,{
               ADD_VAR(peak);
               ADD_VAR(decay_coeff);
               ADD_VAR(growth_coeff);
               ADD_BASE(AudioNode);
           })
MAKE_VISIT_IMPL(Resample,{
               ADD_VAR(last);
               ADD_VAR(rate);
               ADD_VAR(sample_pos);
               ADD_VAR(curr_pos);
               ADD_BASE(AudioNode);
           })
MAKE_VISIT_IMPL(AudioSource3D, {
    ADD_VAR(position);
    ADD_VAR(last_position);
    ADD_VAR(last_frame);
});
MAKE_VISIT_IMPL(Listener,{
               ADD_VAR(speed_of_sound);
               ADD_VAR(attenuation_of_air);
               ADD_VAR(direction_factor);
               ADD_VAR(position);
               ADD_VAR(last_position);
               ADD_VAR(direction);
               ADD_VAR(last_frame);
               ADD_BASE(AudioNode);
           });
};


