//Generated by the Argon Build System

//
//  VirtualImageResource.cpp
//  ArgonEngineApp
//
//  Created by Skyler Saleh on 3/23/13.
//
//

#include "VirtualResourceImage.h"
#include <stb/stb_image.h>
#include <stb/stb_image_write.h>
#include "Thread.h"
namespace Argon{
    bool VirtualResourceImage::save(VirtualResourceIMPL::Source*source){
        if(source&&image_data){
            int out_len=0;
            int components = 4;
            unsigned char * dt = new unsigned char[width*height*4];
            Vector4f d;
            for(int y=0;y<height;++y)
            for(int x=0;x<width;++x){
                d = get_pixel_color(x, y);
                dt[(x+y*width)*4]= std::min(std::max(d[0],0.f), 1.f)*255.f;
                dt[(x+y*width)*4+1]= std::min(std::max(d[1],0.f), 1.f)*255.f;
                dt[(x+y*width)*4+2]= std::min(std::max(d[2],0.f), 1.f)*255.f;
                dt[(x+y*width)*4+3]= std::min(std::max(d[3],0.f), 1.f)*255.f;

            }

            unsigned char* dat=stbi_write_png_to_mem(dt,0,width,height,components,&out_len);
            source->resize(out_len);
            source->write((char*)dat, out_len, 0);
            source->save();
            free(dat);
            return true;

        }
        return false;
    }
    struct image_load_data{
        VirtualResourceIMPL::Source *source;
        VirtualResourceImage* image;
    };
    void * deffered_loading(void* data_pt){

         image_load_data* image = (image_load_data*)data_pt;
        if(!image->source || !image->source->reload())return NULL;
        image->image->load_mutex.lock();
        size_t read =0;
        size_t next_addition=0;
        size_t actual_size=0;
        VirtualResourceImage * im = image->image;
        int x=0,y=0,c=0;
        stbi_ldr_to_hdr_gamma(2.2);
        stbi_convert_iphone_png_to_rgb(true);
        float * dat=NULL;
        std::string data;
        data.resize(0);
        if(uint8_t * d= image->source->get_pointer()){
            dat=(float*)stbi_loadf_from_memory((stbi_uc*)d, image->source->size(), &x, &y, &c, STBI_rgb_alpha);

        }else{
            while(read==next_addition){
                size_t off = data.size();
                next_addition = off/2+512;
                data.resize(off+next_addition);
                read = image->source->read(&data[off], next_addition,off);
                actual_size+=read;
                data.resize(actual_size);
            }

            dat=(float*)stbi_loadf_from_memory((stbi_uc*)&data[0], data.size(), &x, &y, &c, STBI_rgb_alpha);
        }

        if(im->get_width()==-1){
            if(im->get_height()==-1){
                im->create(x,y,im->get_format());
            }else{
                float scale = float(im->get_height())/y;
                im->create(x*scale,im->get_height(),im->get_format());
            }
        }

        if(im->get_height()==-1){
            if(im->get_width()==-1){
                im->create(x,y,im->get_format());
            }else{
                float scale = float(im->get_width())/x;
                im->create(im->get_width(),y*scale,im->get_format());
            }
        }

        im->preloading=false;
        im->load_mutex.unlock();
        float pixel_x = 1.0/x;
        float pixel_y = 1.0/y;
        for(int yi=0;yi<y;++yi)
        for(int xi=0;xi<x;++xi){
            const float *d = dat+(xi+yi*x)*4;
            im->set_sample_color(xi*pixel_x,yi*pixel_y,Vector4f(d[0],d[1],d[2],d[3]));

        }
        stbi_image_free((char*)dat);

        ++im->update_id_;

        return NULL;

    }
    unsigned int VirtualResourceImage::parse_format( std::map<std::string,std::string>&arg_map)const{
        std::string & f = arg_map["f"];
        unsigned int format =kTextureRGBA8;
        if(f=="RGB565")format=kTextureRGB565;
        else if(f=="RGB8")format = kTextureRGB8;
        else if(f=="RGBF16")format=kTextureRGBF16;
        else if(f=="RGBF32")format=kTextureRGBF32;
        else if(f=="RGBF64")format=kTextureRGBF64;

        else if(f=="RGBA5551")format =kTextureRGBA5551;
        else if(f=="RGBA4")format =kTextureRGBA4;
        else if(f=="RGBA8")format =kTextureRGBA8;
        else if(f=="RGBAF16")format =kTextureRGBAF16;
        else if(f=="RGBAF32")format =kTextureRGBAF32;
        else if(f=="RGBAF64")format =kTextureRGBAF64;

        else if(f=="D16")format =kTextureDepth16;
        else if(f=="D24")format =kTextureDepth24;
        else if(f=="D32")format =kTextureDepth32;

        else if(f=="S8")format =kTextureStencil8;
        else if(f=="DS")format =kTextureDepthStencil;
        else std::cout<<"Unknown tex format: "<<f<<"\n";




        int mip = string_to_number(arg_map["mip"]);
        int filter = string_to_number(arg_map["filter"]);
        int filter_mip = string_to_number(arg_map["filter_mip"]);
        int ansio = string_to_number(arg_map["ansiotropic"]);
        int clamp = string_to_number(arg_map["clamp"]);
        int fbo = string_to_number(arg_map["fbo"]);




        if(ansio>=8)format|=kTextureAnsiotropic8x;
        else if(ansio>=4)format|=kTextureAnsiotropic4x;
        else if(ansio>=1)format|=kTextureAnsiotropic2x;

        if(clamp)format|=kTextureClamp;
        if(!mip)format|=kTextureDontMipmap;
        if(!filter)format|=kTextureDontFilterPixels;
        if(!filter_mip)format|=kTextureDontFilterMipmap;
        if(fbo)format|=kTextureFBO;
        return format;
    }
    bool VirtualResourceImage::reload(VirtualResourceIMPL::Source*source){
        if(preloading)return true;
        preloading=true;
        image_load_data * d = new image_load_data;
        d->image =this;
        d->source = source;

        load_thread.launch(deffered_loading, d);

        return true;
    }

}
