//Generated by the Argon Build System

#include "Thread.h"
#include "config.h"
#include <stdio.h>
#if PLATFORM_UNIX==1
	#define USE_SYSTIME
	#include <sys/time.h>
#else
	#ifdef USE_GLFW
		#define GLFW_TIME
		#include <GLFW/glfw3.h>
	#endif
	#ifdef USE_SDL
		#define SDL_TIME
		#include <SDL2/SDL.h>
	#endif
#endif
#ifdef PLATFORM_WINDOWS
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#endif
namespace Argon
{
#if USE_PTHREADS==1
    Thread::Thread(void *(*function)(void*), void* data)
    {
        
        launch(function,data);
    }
    
    void Thread::launch(void *(*function)(void*), void* data){
        pthread_t thread;
        
        int retValue = pthread_create(&thread, NULL, function, data);
        if (retValue) {
            printf("Fatal: Failed to create thread errorcode:%d\n", retValue);
        }
        threadPrimitive = &thread;
        
    }
    void Thread::join()
    {
        if(threadPrimitive)
            pthread_join(*(pthread_t*)threadPrimitive, NULL);
    }
    void Thread::sleep(float secs)
    {
        if(secs<0.0f)return;
        struct timespec sleepval,returnVal;
        sleepval.tv_sec = secs;
        sleepval.tv_nsec = secs*1000000000.0f;
        while(nanosleep(&sleepval, &returnVal))
        {
            sleepval = returnVal;
        }
    }
    Thread::~Thread(){
        join();
    }
#elif PLATFORM_WINDOWS==1
    Mutex::Mutex(){
        HANDLE * win_t = new HANDLE;
        *win_t=CreateMutex(NULL,FALSE,NULL);
        mutex=(void*)win_t;
    }
    void Mutex::lock(){WaitForSingleObject(*(HANDLE*)mutex,INFINITE);}
    bool Mutex::lockOrSkip(){return WaitForSingleObject(*(HANDLE*)mutex,0)!=WAIT_TIMEOUT;}
    void Mutex::unlock(){ReleaseMutex(*(HANDLE*)mutex);}
    Mutex::~Mutex(){
        unlock();
        delete (HANDLE*)mutex;
    }
    Thread::Thread(void *(*function)(void*), void* data)
    {
        
        launch(function,data);
    }
    
    struct ThreadWrapData{
        void*(*function)(void*);
        void* data;
    };
    DWORD WINAPI thread_wrapper_func(LPVOID lpParam){
        ((ThreadWrapData*)lpParam)->function(((ThreadWrapData*)lpParam)->data);
        delete (ThreadWrapData*)lpParam;
        return 0;
    }
    void Thread::launch(void *(*function)(void*), void* data){
        HANDLE thread;
        ThreadWrapData*d = new ThreadWrapData;
        d->function=function;
        d->data=data;
        thread = CreateThread(NULL,0,thread_wrapper_func,d,0,NULL);
        if (!thread) {
            printf("Fatal: Failed to create thread\n");
        }
        threadPrimitive = (void*)thread;
        
    }
    void Thread::join()
    {
        if(threadPrimitive)
            WaitForSingleObject((HANDLE)threadPrimitive,INFINITE);
    }
    void Thread::sleep(float secs)
    {
        if(secs<0.0f)return;
        int ms=secs*1000+0.5;
        Sleep(ms);
    }
    Thread::~Thread(){
        join();
    }
#endif
    double Timer::delta_time(){
        double current =time();
        float d2 =delta_time_;
        delta_time_=current;
        return current-d2;
    }
#ifdef USE_SYSTIME
    Timer::Timer(){
        struct timeval v;
        gettimeofday(&v, NULL);
        timeA=v.tv_sec;
        timeB=v.tv_usec;
        delta_time_=time();
    }
    double Timer::time(){
        struct timeval v;
        gettimeofday(&v, NULL);
        double current =(double)(v.tv_sec-timeA)+(double)(v.tv_usec-timeB)*0.000001;
        return current;
    }
#endif
#ifdef GLFW_TIME
    Timer::Timer(){
        
        delta_time_=time();
    }
    double Timer::time(){
        double current =glfwGetTime();
        return current;
    }
    
#endif
#ifdef SDL_TIME
	Timer::Timer(){

		delta_time_ = time();
	}
	double Timer::time(){
		double v = SDL_GetPerformanceCounter();
		double f = SDL_GetPerformanceFrequency();
		double current = v/f;
		return current;
	}

#endif
}