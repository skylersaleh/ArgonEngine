//Generated by the Argon Build System

//
//  Text.cpp
//  ArgonTest
//
//  Created by Skyler Saleh on 8/7/13.
//  Copyright (c) 2013 Skyler Saleh. All rights reserved.
//

#include "Text.h"
#include "stb/stb_truetype.h"

namespace Argon {

Font::Font():has_loaded(false){
    font=std::make_shared<stbtt_fontinfo>();
}

void Font::get_font_size_ratio(float &w_r, float & h_r){
        int ascent, descent,linegap;
        stbtt_GetFontVMetrics(&*font, &ascent, &descent, &linegap);
        w_r=1./float(ascent-descent);
        h_r=1.;
    }
    void Font::get_glyph_size_ratio(int glyph, float &w_r, float & h_r){
        int ix,iy,ix2,iy2;
        stbtt_GetCodepointBitmapBox(&*font, glyph, 1, 1, &ix, &iy, &ix2, &iy2);
        int ascent, descent,linegap;
        stbtt_GetFontVMetrics(&*font, &ascent, &descent, &linegap);
        w_r=float(ix2-ix)/float(ascent-descent);
        h_r=float(iy2-iy)/float(ascent-descent);
    }

    void Font::get_glyph_size(int glyph, Glyph &g){
        int ix,iy,ix2,iy2;
        stbtt_GetCodepointBitmapBox(&*font, glyph, 1, 1, &ix, &iy, &ix2, &iy2);
        int ascent, descent,linegap;
        stbtt_GetFontVMetrics(&*font, &ascent, &descent, &linegap);
        float scale = 1./float(ascent-descent);
        g.xmin=ix*scale;
        g.xmax=ix2*scale;
        g.ymin=(-descent-iy2)*scale;
        g.ymax=(-descent-iy)*scale;
    }

    float Font::get_advance(int last_glyph,int glyph){
        int advance =0;
        int left_bearing=0;
        float scale = stbtt_ScaleForPixelHeight(&*font, 1);
        stbtt_GetCodepointHMetrics(&*font, last_glyph, &advance, &left_bearing);
        float f = advance;
        //stbtt_GetCodepointHMetrics(&font, glyph, &advance, &left_bearing);
        //f-=left_bearing;
        f+=stbtt_GetCodepointKernAdvance(&*font, last_glyph, glyph);
        return f*scale;;
    }
    void Font::get_glyph_bitmap(int glyph, uint8_t* d, int w, int h,int border){
        int ix,iy,ix2,iy2;
        stbtt_GetCodepointBitmapBox(&*font, glyph, 1, 1, &ix, &iy, &ix2, &iy2);
        float s1 = float(w-border*2)/float(ix2-ix);
        float s2 = float(h-border*2)/float(iy2-iy);

        stbtt_MakeCodepointBitmap(&*font, d+w*border+border, w-border, h-border, w, s1, s2, glyph);
    };

    bool Font::reload(Argon::VirtualResourceIMPL::Source* s){
        if(uint8_t*d =s->get_pointer())stbtt_InitFont(&*font, (const unsigned char*)d, 0);
        else{

        data.resize(s->size());
        s->read(&data[0], data.size(), 0);

        stbtt_InitFont(&*font, (const unsigned char*)data.c_str(), 0);
        }
        has_loaded=true;
        return true;
    }

    VirtualResourceIMPL::Data* Font::clone_type(const std::string& arguments)const{
        Font* f = new Font;
        *f=*this;
        return f;
    }
    GlyphCache::GlyphCache(){
        texture = "virtual://glyph_cache/texture.png{w=h=1024; f=RGBA8; mip=0; ansiotropic:4}";

        image = texture.get_data<Argon::VirtualResourceImage*>();


    };
    inline void GlyphCache::set_val(const int x,int y, unsigned char* array){

        typedef const unsigned char vt;
        const int x2= x-1;
        const int x3= x+1;

        array+=y*kGlyphRenderRes-kGlyphRenderRes;
        unsigned char &c = array[x+kGlyphRenderRes];

        if(c==255)return;
        vt c6 = array[x2];
        vt c3 = array[x];
        vt c8 = array[x3];
        array+=kGlyphRenderRes;

        vt c1 = array[x2];
        vt c2 = array[x3];

        array+=kGlyphRenderRes;
        vt c7 = array[x2];
        vt c4 = array[x];
        vt c9 = array[x3];

        int c5 = std::max(std::max(c1,c2),std::max(c3,c4))*120;
        int c10 = std::max(std::max(c6,c7),std::max(c8,c9))*119;
        int c11 = (std::max(c10,c5)+80)>>7;

        c11-=2;
        if(c11>c)c=c11;

    }
    unsigned char GlyphCache::interpolate(float x, float y, unsigned char *bu){
        int x1 = x;
        int x2 = x1+1;
        int y1 = y;
        int y2 = y1+1;
        x2 = std::min(x2,kGlyphRenderRes-1);
        y2 = std::min(y2,kGlyphRenderRes-1);

        float a = x-x1;
        float b = y-y1;
        y1*=kGlyphRenderRes;
        y2*=kGlyphRenderRes;
        float v1 =bu[x1+y1]+(bu[x2+y1]-bu[x1+y1])*a;
        float v2 =bu[x1+y2]+(bu[x2+y2]-bu[x1+y2])*a;

        return std::min(v1+(v2-v1)*b+0.5f,255.f);
    }
    void GlyphCache::build_distance_field(uint8_t * bu,int pos){
        int c= pos%4;
        pos/=4;
        int x = pos*kGlyphWidth;

        int y = x/kGlyphTextureSize;
        x-=y*kGlyphTextureSize;
        y*=kGlyphHeight;


        for(int y=0;y<kGlyphRenderRes*kGlyphRenderRes;++y)if(bu[y]!=0)bu[y]=(1.f-1.f/(bu[y]*bu[y]))*255.f+0.5f;
        for(int i=0;i<2;++i){
            for(int y=kGlyphRenderRes-2;y>2;--y)
                for(int x=1;x<kGlyphRenderRes-2;++x)set_val(x,y, bu);

            for(int y=2;y<kGlyphRenderRes-2;++y){
                for(int x=kGlyphRenderRes-2;x>2;--x)set_val(x,y, bu);
            }
            for(int y=kGlyphRenderRes-2;y>2;--y){
                for(int x=1;x<kGlyphRenderRes-2;++x)set_val(x,y, bu);
            }

            for(int y=2;y<kGlyphRenderRes-2;++y){
                for(int x=kGlyphRenderRes-2;x>2;--x)set_val(x,y, bu);
            }
        }



        float x_factor = kGlyphRFactor;
        float y_factor = x_factor;

        for(int yi=0;yi<kGlyphHeight;++yi){
            for(int xi=0;xi<kGlyphWidth;++xi){
                Argon::Vector4f co = image->get_pixel_color(x+xi, y+yi);
                co[c]=interpolate((xi*x_factor), (yi*y_factor), bu)/float(255.);;
                image->set_pixel_color(x+xi, y+yi, co);
            }
        }
    }
    Glyph* GlyphCache::get_glyph(Argon::VirtualResource font, int glyph){
        Font* f = font.get_data<Font*>();
        if(!f){
            std::cout<<font.get_path_string()<<" is not a valid ttf.\n";
            return NULL;
        }
        GlyphKey k;
        k.resource=font;
        k.glyph=glyph;
        Glyph & g = glyphs[k];
        if(g.glyph!=glyph||g.font!=font){
            size_t pos = glyphs.get_cache_position(k);
            uint8_t buffer[kGlyphRenderRes*kGlyphRenderRes];
            for(int i=0;i<kGlyphRenderRes*kGlyphRenderRes;++i)buffer[i]=0;
            f->get_glyph_bitmap( glyph, buffer,kGlyphRenderRes,kGlyphRenderRes,kGlyphCacheBorder);
            build_distance_field(buffer, pos);
            image->update_id_++;

            int c= pos%4;
            pos/=4;
            size_t x = pos*kGlyphWidth;

            int y = x/kGlyphTextureSize;

            x-=y*kGlyphTextureSize;
            y*=kGlyphHeight;

            g.map_color[0]=c==0?1.:0;
            g.map_color[1]=c==1?1.:0;
            g.map_color[2]=c==2?1.:0;
            g.map_color[3]=c==3?1.:0;

            g.tex_x = float(x)/kGlyphTextureSize;
            g.tex_y = float(y)/kGlyphTextureSize;
            f->get_glyph_size(glyph,g);
            g.font=font;
            g.glyph=glyph;

        }
        return &g;
    }
    Label::Label(){
        vertex_array= std::make_shared<Argon::VertexArray>();
        vertex_array->add_attribute<float>(2, "position");
        vertex_array->add_attribute<float>(2, "texture_coord");
        vertex_array->add_attribute<float>(4, "modifiers");
        vertex_array->add_attribute<uint8_t>(4, "map_location");
        vertex_array->add_attribute<uint8_t>(4, "fill_color");
        vertex_array->add_attribute<uint8_t>(4, "stroke_color");
        vertex_array->add_attribute<uint8_t>(4, "glow_color");

        material=std::make_shared<Argon::Material>();
        material->shader="shader://text_shader.shd";
        uniform.get_texture("texture")=GlyphCache::get_cache().texture;
        material = material;
        cull_face=Argon::kCullNone;
        material->blend=Argon::kBlendAlpha;

    }
    void Label::render_str(const char* string,Argon::VirtualResource font,LineStyle style){
        const char *s =string;
        int size =0;
        float offset = 0.;
        float y_offset=0;
        int last_glyph = '\0';
        Font* f = font.get_data<Font*>();
        while(*s){
            ++size;
            if(s!=string)offset+=f->get_advance(last_glyph,*s);
            last_glyph=*s;
            ++s;
        }
        Glyph*g=GlyphCache::get_cache().get_glyph(font, last_glyph);

        float total_advance = offset+g->xmax;
        if(style==kLineLeft) offset=0;
        else if(style==kLineCenter)offset= -total_advance*0.5;
        else if(style==kLineRight) offset=-total_advance;
        bounds.origin[0]=offset;
        bounds.origin[1]=0;
        bounds.origin[2]=0.;
        vertex_array->set_size(size*6);
        vertex_array->generate_indices();

        Argon::VertexIterator p = vertex_array->begin("position");
        Argon::VertexIterator t = vertex_array->begin("texture_coord");
        Argon::VertexIterator mc = vertex_array->begin("map_location");

        Argon::VertexIterator m = vertex_array->begin("modifiers");
        Argon::VertexIterator fc = vertex_array->begin("fill_color");
        Argon::VertexIterator gc = vertex_array->begin("glow_color");
        Argon::VertexIterator sc = vertex_array->begin("stroke_color");

        s = string;
        last_glyph = '\0';

        while(*s){
            Glyph *g=GlyphCache::get_cache().get_glyph(font, *s);
            if(s!=string)offset+=f->get_advance(last_glyph,*s);

            float px1 = offset+g->xmin;
            float px2 = offset+g->xmax;
            float py1 =y_offset+g->ymin;
            float py2 =y_offset+g->ymax;
            (p++).set(Argon::Vector2f(px1,py1));
            (p++).set(Argon::Vector2f(px2,py1));
            (p++).set(Argon::Vector2f(px1,py2));

            (p++).set(Argon::Vector2f(px2,py1));
            (p++).set(Argon::Vector2f(px2,py2));
            (p++).set(Argon::Vector2f(px1,py2));
            float off = 1.5/float(kGlyphTextureSize);
            float xm = g->tex_x+off;
            float ym = g->tex_y+off;

            float xmx = xm + float(kGlyphWidth)/kGlyphTextureSize-2*off;
            float ymx = ym + float(kGlyphHeight)/kGlyphTextureSize-2*off;

            (t++).set(Argon::Vector2f(xm,ymx));
            (t++).set(Argon::Vector2f(xmx,ymx));
            (t++).set(Argon::Vector2f(xm,ym));

            (t++).set(Argon::Vector2f(xmx,ymx));
            (t++).set(Argon::Vector2f(xmx,ym));
            (t++).set(Argon::Vector2f(xm,ym));

            (mc++).set(g->map_color);
            (mc++).set(g->map_color);
            (mc++).set(g->map_color);
            (mc++).set(g->map_color);
            (mc++).set(g->map_color);
            (mc++).set(g->map_color);

            last_glyph=*s;

            ++s;
        }
        offset+=f->get_advance(last_glyph,*s);
        bounds.size[0]=offset-bounds.origin[0];
        bounds.size[1]=1.0;
        vertex_array->update_id++;
    }
    MAKE_VISIT_IMPL(Label,{
                        ADD_BASE(Renderable);

                    })

};
