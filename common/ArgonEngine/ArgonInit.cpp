//Generated by the Argon Build System

#include "ArgonInit.h"
#define  GLFW_USE_CHDIR 1
#include <stdlib.h>
#include "Utility.h"
#include "Hardware.h"
#include "VirtualResource.h"
#ifdef USE_GLEW
#include "GL/glew.h"
#endif
#ifdef USE_SDL
#include "SDL2/SDL.h"
#ifdef USE_OPENGL
#ifndef USE_OPENGLES
#include "SDL2/SDL_opengl.h"
#endif
#endif
#ifdef USE_OPENGLES
    #include "SDL2/SDL_opengles2.h"
#endif
#endif

#ifdef USE_GLFW
#include "GLFW/glfw3.h"
#endif
#ifdef PLATFORM_UNIX
#include <unistd.h>
#include <pwd.h>
#endif
#ifdef USE_RTAUDIO
#include <RtAudio/RtAudio.h>
#endif
#include <iostream>
#include "AudioSystem.h"

#define ANSI_COLOR_RED     "\x1b[31m"
#define ANSI_COLOR_GREEN   "\x1b[32m"
#define ANSI_COLOR_YELLOW  "\x1b[33m"
#define ANSI_COLOR_BLUE    "\x1b[34m"
#define ANSI_COLOR_MAGENTA "\x1b[35m"
#define ANSI_COLOR_CYAN    "\x1b[36m"
#define ANSI_COLOR_RESET   "\x1b[0m"
namespace Argon{
    static void (*manual_redraw)()=NULL;
    bool run=true;
    Vector2f last_screen;
    Vector2f last_position;

    Vector2f last_minimum_size;
    bool last_screen_enabled=true;
    bool last_full_screen;
    std::string last_title;

    void set_manual_redraw(void (*draw)()){manual_redraw=draw;}

    static void InitVirtual(std::string organization_name, std::string app_name){
        std::cout<<"Argon Engine"<<std::endl;
        std::cout<<"------------"<<std::endl;

#ifdef USE_SDL
        std::string base = SDL_GetBasePath();
        char* c = SDL_GetPrefPath(organization_name.c_str(),app_name.c_str());
        std::string doc_dir = c;
        SDL_free(c);
        std::string home ="";
        std::string pref_dir = c;
        std::string tmp_dir = pref_dir;
#ifdef PLATFORM_UNIX
         home = getenv("HOME");
        if (!home.size()) {
            struct passwd* pwd = getpwuid(getuid());
            if (pwd)
               home = pwd->pw_dir;
        }
        doc_dir=home;

        std::cout<<"Home directory is "<<home<<"\n";
        tmp_dir = getenv("TMPDIR");
        std::cout<<"TMP directory is "<<tmp_dir<<"\n";
#endif
#endif
#ifdef PLATFORM_MAC
        doc_dir = home+"/Documents";
        pref_dir = home+"/Library/Application Support/"+organization_name+"/"+app_name;
#endif
        std::cout<< "Save files are stored in "<<doc_dir<<"\n";

        VirtualResource::all_sources()["document:"]=new VirtualResourceIO(doc_dir,true);
        VirtualResource::all_sources()["resource:"]=new VirtualResourceIO(base+"resources",false);
        VirtualResource::all_sources()["shader:"]=new VirtualResourceIO(base+"shaders",false);
        VirtualResource::all_sources()["user:"]=
        VirtualResource::all_sources()["home:"]=new VirtualResourceIO(home,true);
        VirtualResource::all_sources()["save:"]=
        VirtualResource::all_sources()["app-data:"]=
        VirtualResource::all_sources()["pref:"]=new VirtualResourceIO(pref_dir,true);
        VirtualResource::all_sources()["cache:"]=
        VirtualResource::all_sources()["tmp:"]=new VirtualResourceIO(tmp_dir,true);

        Argon::VirtualResource::initialize();


    }
    void update_frame(){
        Argon::Listener::current_frame++;
        Argon::AudioSource3D* curr = Argon::AudioSource3D::root_source;
        while(curr){
            curr->finalize_data();
            curr=curr->next_source;
        }

    }

#ifdef USE_GLFW
    void resize(GLFWwindow* window, int x, int y);
    void MouseCallback(GLFWwindow* window, double x, double y);
    static void KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void ScrollCallback(GLFWwindow* window, double x, double y);
    static void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
    static void CursorEnterCallback(GLFWwindow* window, int entered);
    static void WindowMinimizeCallback(GLFWwindow* window, int iconified);
    static void WindowFocusCallback(GLFWwindow* window, int focused);
    GLFWwindow* main_window;

    static void Terminate(int code){
        glfwTerminate();
        exit(code);
    }

    static void InitWindow(){
        if(glfwInit()!=GL_TRUE)return Terminate(1);
        glfwDefaultWindowHints();
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,2);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,1);
        glfwWindowHint(GLFW_SAMPLES,4);
        glfwWindowHint(GLFW_ALPHA_BITS, 8);
        //if(glfwOpenWindow(800,600,8,8,8,8,24,0,GLFW_WINDOW)!=GL_TRUE)return Terminate(1);

        if(!(main_window=glfwCreateWindow(800,600,"ArgonEngineApp",NULL,NULL))){
            std::cout<<"Couldn't create window\n";
            Terminate(-1);
        }
        Argon::Screen::width=800;
        Argon::Screen::height=600;
        last_full_screen=Screen::full_screen;
        last_screen=Vector2f(Screen::width,Screen::height);
        glfwMakeContextCurrent(main_window);

        glfwSetWindowSizeCallback(main_window,&resize);
        glfwSetCursorPosCallback(main_window,&MouseCallback);
        glfwSetKeyCallback(main_window, &KeyCallback);
        glfwSetScrollCallback(main_window, &ScrollCallback);
        glfwSetMouseButtonCallback(main_window, &MouseButtonCallback);
        glfwSetCursorEnterCallback(main_window, &CursorEnterCallback);
        glfwSetWindowFocusCallback(main_window, &WindowFocusCallback);
        glfwSetWindowIconifyCallback(main_window, &WindowMinimizeCallback);
        glfwSwapInterval(1);



    }

    static void WindowFocusCallback(GLFWwindow* window, int focused)
    {
        Argon::Input::push_update(kInputIDWindowInactive, !focused);
    }

    static void WindowMinimizeCallback(GLFWwindow* window, int iconified)
    {
        Argon::Input::push_update(kInputIDWindowMinimized, iconified);
    }

    void resize(GLFWwindow* window, int x, int y)
    {
        Argon::Screen::width=x;
        Argon::Screen::height=y;
    }
    void MouseCallback(GLFWwindow* window, double x,double y){
        if(Argon::Screen::height&&Argon::Screen::width){
            Argon::Input::push_update(kInputIDMouseX, x/Argon::Screen::width*2.-1.);
            Argon::Input::push_update(kInputIDMouseY, y/Argon::Screen::height*-2.+1.);
        }
    }
    static void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)
    {
        if(button==2)button=1;
        else if (button==1)button=2;

        if(action==GLFW_PRESS)
            Argon::Input::push_update(kInputIDMouseButton0+button, 1.0);
        else if(action==GLFW_RELEASE)
            Argon::Input::push_update(kInputIDMouseButton0+button, 0.0);
    }
    static void ScrollCallback(GLFWwindow* window, double x, double y)
    {
        Argon::Input::push_update(kInputIDMouseHorzScroll, x);
        Argon::Input::push_update(kInputIDMouseVertScroll, y);
    }
    static void KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
    {


        if(action==GLFW_PRESS)
            Argon::Input::push_update(kInputKeyboard|uint16_t(key), 1.0);
        else if(action==GLFW_RELEASE)
            Argon::Input::push_update(kInputKeyboard|uint16_t(key), 0.0);

    }
    void PollJoysticks(){
        for(int x=GLFW_JOYSTICK_1;x<GLFW_JOYSTICK_LAST;++x)
        {
            if(glfwJoystickPresent(x)){
                int size =0;
                const float* axes=glfwGetJoystickAxes(x, &size);
                uint8_t device_bits = Argon::kInputDevice0+x;
                for(int i=0;i<size;++i){
                    uint16_t axis_bits = Argon::kInputAxisX+i;
                    Argon::Input::push_update(Argon::kInputJoy|device_bits|axis_bits, axes[i]);
                }
                size=1;
                const uint8_t* buttons=glfwGetJoystickButtons(x, &size);
                for(int i=0;i<size;++i){
                    uint16_t axis_bits = i;
                    Argon::Input::push_update(Argon::kInputJoy|device_bits|axis_bits, buttons[i]);
                }
            }
        }
    }
    static void CursorEnterCallback(GLFWwindow* window, int entered)
    {
        Argon::Input::push_update(kInputIDWindowHasMouse, entered);
    }
    static void SetGamma(GLFWwindow* window, float value)
    {
        GLFWmonitor* monitor = glfwGetWindowMonitor(window);
        if (!monitor)
            monitor = glfwGetPrimaryMonitor();

        float gamma_value = value;
        glfwSetGamma(monitor, gamma_value);
    }



    int audio_callback( void *outputBuffer, void *inputBuffer, unsigned int nBufferFrames,
                       double streamTime, RtAudioStreamStatus status, void *data )
    {
        float *buffer = (float *) outputBuffer;

        if ( status )
            std::cout << "Stream underflow detected!" << std::endl;

        for (size_t i=0; i<Argon::kAudioBufferSize*2; ++i) buffer[i]=0;

        for(size_t i=0;i<Argon::kAudioNumberOfChannels;++i)
            if(Argon::AudioNode::root_nodes[i])  Argon::AudioNode::root_nodes[i]->render(buffer+i*Argon::kAudioBufferSize);
        update_frame();

        return 0;
    }
    void cleanup_rtaudio(RtAudio&dac){
        if ( dac.isStreamOpen() ) {
            try {dac.stopStream();}
            catch ( RtError& e ) {
                e.printMessage();
            }
            dac.closeStream();
        }
    }
    void init_rtaudio(RtAudio &dac){
        InitVirtual();
        unsigned int bufferFrames;


        if ( dac.getDeviceCount() < 1 ) {
            std::cout << "\nNo audio devices found!\n";
            cleanup_rtaudio(dac);
        }

        // Let RtAudio print messages to stderr.
        dac.showWarnings( true );

        // Set our stream parameters for output only.
        bufferFrames =Argon::kAudioBufferSize;
        RtAudio::StreamParameters oParams;
        oParams.deviceId = dac.getDefaultOutputDevice();
        oParams.nChannels = Argon::kAudioNumberOfChannels;
        oParams.firstChannel = 0;
        RtAudio::StreamOptions options;
        options.flags = RTAUDIO_SCHEDULE_REALTIME | RTAUDIO_NONINTERLEAVED;

        try {
            dac.openStream( &oParams, NULL, RTAUDIO_FLOAT32, Argon::kAudioSampleRate, &bufferFrames, &audio_callback, NULL, &options );
            dac.startStream();
        }
        catch ( RtError& e ) {
            e.printMessage();
            cleanup_rtaudio(dac);
        }
    }
    RtAudio dac;
    void initialize_engine(){
        InitWindow();
        InitVirtual();
        init_rtaudio(dac);

        int code=0;

        if(GLEW_OK!=(code=glewInit())){
            std::cout<<"GLEW Failed to init: "<<code<<"\n"; Terminate(-1);
        };
        if(!GLEW_VERSION_2_0){
            std::cout<<"OpenGL 2.0 is required\n"; Terminate(-1);
        };
        SetGamma(main_window,1.0);

    }
    void terminate_engine(){
        glfwDestroyWindow(main_window);
        std::cout<<"Quit\n";
        cleanup_rtaudio(dac);
        Terminate(0);
    }
    bool poll_events(){
        glfwPollEvents();
        PollJoysticks();
        return !glfwWindowShouldClose(main_window);
    }

    void swap_buffers(){
        glfwSwapBuffers(main_window);
    }
#endif

#ifdef USE_SDL
    static SDL_GLContext context;
    static SDL_Window *win = nullptr;
    int handle_event(void* userdata,SDL_Event* event);

    void terminate_engine(){
        if (context) {
            /* SDL_GL_MakeCurrent(0, NULL); *//* doesn't do anything */
            SDL_GL_DeleteContext(context);
        }
        SDL_Quit();


        exit(0);
    }
    SDL_AudioDeviceID dev;
    int audio_buffer_index=0;
    float audio_buffer[Argon::kAudioNumberOfChannels][Argon::kAudioBufferSize];

    void sdl_audio_callback(void *userdata, Uint8 * stream,int len){
        float *buffer = (float *) stream;
        len = len/4;
        for(int o=0;o<len;){
            if(audio_buffer_index==Argon::kAudioBufferSize){
                for(size_t c=0;c<Argon::kAudioNumberOfChannels;++c)
                    for (size_t i=0; i<Argon::kAudioBufferSize; ++i) audio_buffer[c][i]=0;

                for(size_t i=0;i<Argon::kAudioNumberOfChannels;++i)
                    if(Argon::AudioNode::root_nodes[i])  Argon::AudioNode::root_nodes[i]->render(audio_buffer[i]);
                audio_buffer_index=0;
            }
            for(size_t c=0;c<Argon::kAudioNumberOfChannels;++c){
                buffer[o++]=audio_buffer[c][audio_buffer_index];
            }
            ++audio_buffer_index;


        }

        update_frame();

    }
    void init_audio(){
        SDL_AudioSpec want, have;
        SDL_zero(want);
        want.freq = Argon::kAudioSampleRate;
        want.format = AUDIO_F32SYS;
        want.channels = 2;
        want.samples = Argon::kAudioBufferSize;
        want.callback=sdl_audio_callback;

        if (SDL_OpenAudio(&want, &have) < 0) {
            printf("Failed to open audio: %s\n", SDL_GetError());
        }
        SDL_PauseAudio(0);
    }
    void initialize_engine(std::string organization_name, std::string app_name){
        SDL_SetMainReady();

        if (SDL_Init(SDL_INIT_EVERYTHING) == -1){
            std::cout << SDL_GetError() << std::endl;
            terminate_engine();
        }

        //Enable VSync
        if( !SDL_SetHint( SDL_HINT_RENDER_VSYNC, "1" ) )
        {
            printf( "Warning: VSync not enabled!" );
        }

        InitVirtual(organization_name, app_name);
        init_audio();

        SDL_Rect r;
        SDL_GetDisplayBounds(0, &r);
        Argon::Screen::size=Vector2f(512, 512);
        Argon::Screen::position=Vector2f(100, 100);
        Argon::Screen::actual_size=Vector2f(r.w,r.h);
        last_full_screen=Screen::full_screen;
        last_screen=Screen::size;
        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES,4);
        SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);

        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

        //SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
        win = SDL_CreateWindow("test", 100, 100, Argon::Screen::size[0], Argon::Screen::size[1],  SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);

        // Create an OpenGL context associated with the window.
        //SDL_GLContext glcontext = SDL_GL_CreateContext(win);

        context=SDL_GL_CreateContext(win);
        SDL_GL_MakeCurrent(win, context);
#ifdef USE_GLEW
        glewExperimental = GL_TRUE;
        //SDL_GL_MakeCurrent(win, glcontext);

        int code = 0;
        if(GLEW_OK!=(code=glewInit())){
            std::cout << glewGetErrorString(code) << "\n";
            std::cout<<"GLEW Failed to init: "<<code<<"\n";
        };
        if(!GLEW_VERSION_2_0){
            std::cout<<"OpenGL 2.0 is required\n";
        };
#endif
        //SDL_AddEventWatch(handle_event, NULL);
        if (SDL_GL_SetSwapInterval(-1) != -1){}
        else if (SDL_GL_SetSwapInterval(1) != -1){}
        else std::cout << "Could not enable VSync.\n";

        SDL_SetEventFilter(handle_event, NULL);

    }
    uint32_t sdl_key_to_argon(SDL_Keycode key){
        if(key>=SDLK_F1&&key<=SDLK_F12)return kInputIDF1+key-SDLK_F1;
        else if(key>=SDLK_F13&&key<=SDLK_F24)return  kInputIDF13+key-SDLK_F13;
        else if(key>=SDLK_KP_1&&key<=SDLK_KP_9)return kInputKeyboard|uint16_t(key-SDLK_KP_1 +321);

        switch (key) {
            case SDLK_KP_0: return kInputIDKP0;
            case SDLK_KP_DECIMAL: return kInputIDKPDecimal;
            case SDLK_KP_DIVIDE: return kInputIDKPDivide;
            case SDLK_KP_MULTIPLY: return kInputIDKPMultiply;
            case SDLK_KP_MINUS: return kInputIDKPSubtract;
            case SDLK_KP_PLUS: return kInputIDKPAdd;
            case SDLK_KP_ENTER: return kInputIDKPEnter;
            case SDLK_KP_EQUALS: return kInputIDKPEqual;

            case SDLK_LSHIFT:return kInputIDLeftShift;
            case SDLK_RSHIFT:return kInputIDRightShift;

            case SDLK_LALT:return kInputIDLeftAlt;
            case SDLK_RALT:return kInputIDRightAlt;

            case SDLK_LCTRL:return kInputIDLeftControl;
            case SDLK_RCTRL:return kInputIDRightControl;

            case SDLK_LGUI:return kInputIDLeftSuper;
            case SDLK_RGUI:return kInputIDRightSuper;

            case SDLK_MENU:return kInputIDMenu;

            case SDLK_UP:return kInputIDUp;
            case SDLK_DOWN:return kInputIDDown;
            case SDLK_RIGHT:return kInputIDRight;
            case SDLK_LEFT:return kInputIDLeft;

            case SDLK_ESCAPE:return kInputIDEscape;
            case SDLK_RETURN:return kInputIDEnter;
            case SDLK_TAB:return kInputIDTab;
            case SDLK_BACKSPACE:return kInputIDBackspace;
            case SDLK_INSERT:return kInputIDInsert;
            case SDLK_DELETE:return kInputIDDelete;

            case SDLK_PAGEUP:return kInputIDPageUp;
            case SDLK_PAGEDOWN:return kInputIDPageDown;
            case SDLK_HOME:return kInputIDHome;
            case SDLK_END:return kInputIDEnd;
            case SDLK_CAPSLOCK:return kInputIDCapsLock;
            case SDLK_SCROLLLOCK:return kInputIDScrollLock;
            case SDLK_NUMLOCKCLEAR:return kInputIDNumLock;
            case SDLK_PRINTSCREEN:return kInputIDPrintScreen;
            case SDLK_PAUSE:return kInputIDPause;




        }


        return key;
    }
    void handle_joy_axis_event(SDL_Event &e){
        uint32_t axis = e.jaxis.axis;
        if(axis>1)++axis;
        if(axis>5)++axis;
        uint32_t id = kInputJoy| (kInputDeviceIncrement*e.jaxis.which)|(kInputAxisIncrement*axis+kInputAxisAnalogStart);
        Argon::Input::push_update(id, e.jaxis.value/32768.f);
    }
    void handle_joy_button_event(SDL_Event &e){
        uint32_t id = kInputJoy| (kInputDeviceIncrement*e.jbutton.which)|(kInputAxisIncrement*e.jbutton.button+kInputAxisButtonStart);
        Argon::Input::push_update(id, e.jbutton.state);
    }
    void handle_joy_hat_event(SDL_Event &e){
        uint32_t id = kInputJoy| (kInputDeviceIncrement*e.jhat.which)|(kInputAxisIncrement*e.jhat.hat+kInputAxisHatStart);
        Argon::Input::push_update(id, e.jhat.value);
    }

    void handle_window_event(SDL_Event &e){
        switch (e.window.event) {
            case SDL_WINDOWEVENT_MOVED:
                Argon::Screen::position=Vector2f(e.window.data1,e.window.data2);
                last_position=Argon::Screen::position;
                break;
            case SDL_WINDOWEVENT_RESIZED:
                Argon::Screen::size=Vector2f(e.window.data1,e.window.data2);
                last_full_screen=Screen::full_screen;
                last_screen=Screen::size;
                if(manual_redraw){
                    //Redraw twice to fully update deffered state.
                    manual_redraw();
                    manual_redraw();
                }

                swap_buffers();

                break;
            case SDL_WINDOWEVENT_MINIMIZED:
                Argon::Input::push_update(kInputIDWindowMinimized, 1);
                break;

            case SDL_WINDOWEVENT_RESTORED:
                Argon::Input::push_update(kInputIDWindowMinimized, 0);
                break;

            case SDL_WINDOWEVENT_ENTER:
                Argon::Input::push_update(kInputIDWindowHasMouse, 1);
                break;
            case SDL_WINDOWEVENT_LEAVE:
                Argon::Input::push_update(kInputIDWindowHasMouse, 0);
                break;
            case SDL_WINDOWEVENT_EXPOSED:
            case SDL_WINDOWEVENT_SHOWN:
            case SDL_WINDOWEVENT_FOCUS_GAINED:
                Argon::Input::push_update(kInputIDWindowInactive, 0);

                break;
            case SDL_WINDOWEVENT_HIDDEN:
            case SDL_WINDOWEVENT_FOCUS_LOST:
                Argon::Input::push_update(kInputIDWindowInactive, 1);

                break;

        }
    }
    std::map<int32_t, SDL_Joystick*> joys;
    int handle_event(void* userdata,SDL_Event* event){
        SDL_Event e=*event;
        //Handle events on queue
        //while( SDL_PollEvent( &e ) != 0 )
        {
            //User requests quit
            if( e.type == SDL_QUIT )
            {
                run=false;
            }else if (e.type==SDL_JOYDEVICEADDED){
                SDL_Joystick* &j = joys[e.jdevice.which];
                if(!j) j=SDL_JoystickOpen(e.jdevice.which);
            }else if (e.type==SDL_JOYDEVICEREMOVED){
                SDL_Joystick* &j = joys[e.jdevice.which];
                if(j) SDL_JoystickClose(j);
                j=NULL;
            }else if (e.type==SDL_MOUSEMOTION){
                Argon::Input::push_update(kInputIDMouseX, e.motion.x/Argon::Screen::size[0]*2.-1.);
                Argon::Input::push_update(kInputIDMouseY, e.motion.y/Argon::Screen::size[1]*-2.+1.);
            }else if(e.type==SDL_MOUSEBUTTONUP||e.type==SDL_MOUSEBUTTONDOWN){
                Argon::Input::push_update(kInputIDMouseX, e.button.x/Argon::Screen::size[0]*2.-1.);
                Argon::Input::push_update(kInputIDMouseY, e.button.y/Argon::Screen::size[1]*-2.+1.);
                Argon::Input::push_update(kInputMouse|e.button.button, SDL_MOUSEBUTTONDOWN==e.type);


            }else if(e.type==SDL_KEYDOWN||e.type==SDL_KEYUP){
                SDL_Keycode key_c =SDL_GetKeyFromScancode(e.key.keysym.scancode);
                uint32_t key =sdl_key_to_argon(key_c);
                Argon::Input::push_update(key, e.key.state==SDL_PRESSED?1.0:0.);

            }else if(e.type==SDL_WINDOWEVENT)handle_window_event(e);
            else if (e.type ==SDL_JOYAXISMOTION)handle_joy_axis_event(e);
            else if (e.type ==SDL_JOYBUTTONDOWN||e.type==SDL_JOYBUTTONUP)handle_joy_button_event(e);
            else if (e.type ==SDL_JOYAXISMOTION)handle_joy_axis_event(e);
            else if (e.type ==SDL_JOYHATMOTION)handle_joy_hat_event(e);
            else if (e.type==SDL_JOYBALLMOTION){std::cout<<"BALL"<<std::endl;}
            else if (e.type==SDL_MOUSEWHEEL){
                if(e.wheel.which!=SDL_TOUCH_MOUSEID){

                    Argon::Input::push_update(kInputIDMouseHorzScroll, e.wheel.x);
                    Argon::Input::push_update(kInputIDMouseVertScroll, e.wheel.y);
                }
            }
        }
        return true;
    }
    void slow_poll(){
        static int x=0;
        if(++x%10)return;
        if(last_title!=Screen::title){
            SDL_SetWindowTitle(win, Screen::title.c_str());
            last_title=Screen::title;
        }
        if(SleepLock::sleep_enabled()!=last_screen_enabled){
            last_screen_enabled=SleepLock::sleep_enabled();
            if(SleepLock::sleep_enabled())SDL_EnableScreenSaver();
            else SDL_DisableScreenSaver();
        }

        int secs=0,pct=0;
        int state=SDL_GetPowerInfo(&secs, &pct);
        if(state==SDL_POWERSTATE_CHARGING)Input::push_update(kInputIDBatteryState, kBatteryCharging);
        else if(state==SDL_POWERSTATE_CHARGED)Input::push_update(kInputIDBatteryState, kBatteryFull);
        else if(state==SDL_POWERSTATE_ON_BATTERY)Input::push_update(kInputIDBatteryState, kBatteryDischarging);
        else Input::push_update(kInputIDBatteryState, kNoBattery);
        Input::push_update(kInputIDBatteryTimeRemaining, secs);
        Input::push_update(kInputIDBatteryPercent, pct);


    }

    bool poll_events(){
        SDL_Event e;
        while( SDL_PollEvent( &e ) != 0 ){
        }
        if(last_screen!=Screen::size){

            SDL_SetWindowSize(win, Screen::size[0], Screen::size[1]);
            last_screen=Screen::size;

            manual_redraw();
            manual_redraw();

            SDL_GL_MakeCurrent(win, context);
            SDL_GL_SwapWindow(win);
        }
        if(last_minimum_size!=Screen::minimum_size){

            SDL_SetWindowMinimumSize(win, Screen::minimum_size[0], Screen::minimum_size[1]);
            last_minimum_size=Screen::minimum_size;

        }
        if(last_full_screen!=Screen::full_screen){
            SDL_SetWindowFullscreen(win, Screen::full_screen?SDL_WINDOW_FULLSCREEN_DESKTOP:0);
            last_full_screen=Screen::full_screen;
            last_screen=Screen::size;

            manual_redraw();
            manual_redraw();

            SDL_GL_MakeCurrent(win, context);
            SDL_GL_SwapWindow(win);
        }
        if(last_position!=Screen::position){
            last_position=Screen::position;
            SDL_SetWindowPosition(win, last_position[0], last_position[1]);
        }
        slow_poll();

        return run;

    }
    Timer t;
    void swap_buffers(){
        static double accumulator = 0;
        accumulator -= t.delta_time();
        //Linear IFR based accumulator to approximate frame time.
        while(accumulator > 0.0166666666666666666){
            Argon::Thread::sleep(accumulator);
            accumulator -= t.delta_time();
        }
        accumulator += 0.01666666666666666;
        if (accumulator < -0.5)accumulator = -0.5;
        SDL_GL_MakeCurrent(win, context);
        SDL_GL_SwapWindow(win);

    }
#endif

}
