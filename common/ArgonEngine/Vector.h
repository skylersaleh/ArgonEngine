//Generated by the Argon Build System

/**
 * @brief This file includes the Argon::Vector classes and provides an implementation of most common Vector Ops. It is important to remember
 * that any function using operator overloading is component wise. Dot and cross are implemented as functions.
 *
 * @file Vector.h
 * @author Skyler Saleh
 **/

#ifndef Vector2_h
#define Vector2_h
#include "TemplateUtilities.h"
#include <cmath>
#include "TypeInfo.h"
#include <stdlib.h>
#include <Eigen/Eigen>

using namespace Eigen;

namespace Argon {

typedef Eigen::Vector4d Vector4d;     //!< Vector of 4 doubles
typedef Eigen::Vector3d Vector3d;     //!< Vector of 3 doubles
typedef Eigen::Vector2d Vector2d;     //!< Vector of 2 doubles

typedef Eigen::Vector4f Vector4f;     //!< Vector of 4 floats
typedef Eigen::Vector3f Vector3f;     //!< Vector of 3 floats
typedef Eigen::Vector2f Vector2f;     //!< Vector of 2 floats

typedef Eigen::Vector4i Vector4i;     //!< Vector of 4 ints
typedef Eigen::Vector3i Vector3i;     //!< Vector of 3 ints
typedef Eigen::Vector2i Vector2i;     //!< Vector of 2 ints

template <class T, size_t size> using VectorBase = Eigen::Matrix<T,size,1>;


const static Vector4f kRedColor(1,0,0,1);               //!< Holds a Vector representation of the color red.
const static Vector4f kGreenColor(0,1,0,1);             //!< Holds a Vector representation of the color green.
const static Vector4f kBlueColor(0,0,1,1);              //!< Holds a Vector representation of the color blue.

const static Vector4f kYellowColor(1,1,0,1);            //!< Holds a Vector representation of the color yellow.
const static Vector4f kMagentaColor(1,0,1,1);           //!< Holds a Vector representation of the color magenta.
const static Vector4f kCyanColor(0,1,1,1);              //!< Holds a Vector representation of the color cyan.

const static Vector4f kClearColor(0,0,0,0);             //!< Holds a Vector representation of a color that is completely transparent.
const static Vector4f kWhiteColor(1,1,1,1);             //!< Holds a Vector representation of the color white.
const static Vector4f kGrayColor(0.5f,0.5f,0.5f,1);     //!< Holds a Vector representation of the color gray.
const static Vector4f kBlackColor(0,0,0,1);             //!< Holds a Vector representation of the color black.

const static Vector4f kBrownColor(0.62f,0.41f,0.21f,1);      //!< Holds a Vector representation of the color brown.
const static Vector4f kPurpleColor(0.5f,0,0.5f,1);      //!< Holds a Vector representation of the color purple.
const static Vector4f kOrangeColor(1,0.5f,0,1);         //!< Holds a Vector representation of the color orange.
template <typename T, int size>
T distance(const VectorBase<T,size>&a, const VectorBase<T,size>&b){return (a-b).norm();}
template <typename T, int size>
T dot(const VectorBase<T,size>&a, const VectorBase<T,size>&b){return a.dot(b);}
template <typename T, int size>
T length(const VectorBase<T,size>&a){return a.norm();}
template <typename T, int size>
const VectorBase<T,size> normalize(const VectorBase<T,size>&a){return a.normalized();}

template <typename T, int size>
const VectorBase<T,size> max(const VectorBase<T,size>&a,const VectorBase<T,size>&b){
    VectorBase<T,size> v;
    for(size_t i=0;i<size;++i)v[i]=std::max(a[i],b[i]);
    return v;
}
template <typename T, int size>
const VectorBase<T,size> min(const VectorBase<T,size>&a,const VectorBase<T,size>&b){
    VectorBase<T,size> v;
    for(size_t i=0;i<size;++i)v[i]=std::min(a[i],b[i]);
    return v;
}


static inline Vector3f hsv_to_rgb(Vector3f hsv){


    float v = hsv[2];
    hsv[0]=hsv[0]-floor(hsv[0]);
    float i = floor(hsv[0] * 6.);
    float f = hsv[0] * 6. - i;
    float p = hsv[2] * (1 - hsv[1]);
    float q = hsv[2] * (1 - hsv[1] * f);
    float t = hsv[2] * (1 - hsv[1] * (1. - f));

    if(i==0.)return Vector3f(v,t,p);
    else if(i==1) return Vector3f(q,v,p);
    else if(i==2) return Vector3f(p,v,t);
    else if(i==3) return Vector3f(p,q,v);
    else if(i==4) return Vector3f(t,p,v);

    return Vector3f(v,p,q);

}
//! Used to change a 3D vector into a 4D one.
template <typename T,typename T2> VectorBase<T, 4> vect4(const VectorBase<T,3>& v, T2 w){
    return VectorBase<T,4>(v[0],v[1],v[2],w);
}

template <typename T, int size> VectorBase<T,size> random_vector(){
    VectorBase<T,size> random;
    for(int i=0;i<size;++i)random[i]=(rand()/float(RAND_MAX))*2.-1.;
    return random;
}
template <typename T,size_t s1,size_t s2 >
struct TypeInfo<Eigen::Matrix<T,s1,s2> >{
    enum {valid=1};
    static void handle(Matrix<T,s1,s2> &t, Visitor & v){
        v.type_name="Matrix";
        for(size_t y=0;y<t.cols();++y){
            for(size_t x=0; x<t.rows(); ++x){
                v.handle(t(x,y));
            }
        }
    }

};
template <typename T,size_t s1,size_t s2 >
struct TypeInfo<Array<T,s1,s2> >{
    enum {valid=1};
    static void handle(Array<T,s1,s2> &t, Visitor & v){
        v.type_name="Array";

        for(size_t y=0;y<t.size();++y){
            v.handle(t[y]);
        }
    }

};
};

#endif
