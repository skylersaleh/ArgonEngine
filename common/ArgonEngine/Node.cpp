//Generated by the Argon Build System

//
//  ARNode.cpp
//  NeonRush 2
//
//  Created by Skyler Saleh on 6/16/11.
//  Copyright 2011 Argon Software. All rights reserved.
//
#include "Node.h"
#include "RenderSystem.h"
#include "BasicShape.h"
namespace Argon {

bool Node::overlaps_screen_coord(Vector2f coord){
    Matrix4f m = projection_matrix();
    BoundingCube c = bounds.transform(m);
    return c.overlaps_point(coord);
}

Node &Node::operator=(const Node &t){
    parent = t.parent;
    position=t.position;
    rotation=t.rotation;
    anchor=t.anchor;
    scale=t.scale;
    dimensions=t.dimensions;
    color=t.color;
    should_render=t.should_render;
    layer=t.layer;
    bounds = t.bounds;
    return *this;
}

void Node::visit(Visitor &v){
    v.type_name="Node";
    if(v.begin_map()){
        v.handle(position,"position");
        v.handle(rotation,"rotation");
        v.handle(anchor,"anchor");
        v.handle(scale,"scale");
        v.handle(dimensions,"dimensions");
        v.handle(color,"color");
        v.handle(should_render,"should_render");
        v.handle(layer,"layer");
        v.handle(bounds,"bounds");
        v.finish_map();
    }

}

Affine3f Node::world_matrix(){
    return (parent? parent->world_matrix():Affine3f::Identity())*
            Translation3f(position)*
            rotation*
            Scaling(dimensions.cwiseProduct(scale))*
            Translation3f(anchor);
}

Affine3f Node::object_matrix(){
    return Translation3f(position)*
            rotation*
            Scaling(dimensions.cwiseProduct(scale))*
            Translation3f(anchor);

}

Matrix4f Node::get_camera_projection(){
    return Camera::get_main_camera()->projection_matrix;
}

Matrix4f Node::get_camera_view(){
    return Camera::get_main_camera()->matrix;
}
Matrix4f Node::get_camera_inverse_view(){
    return Camera::get_main_camera()->inverse();
}

Matrix4f Node::projection_matrix(){
    Affine3f world_m= world_matrix();
    return (get_camera_projection()* get_camera_view())*world_m.matrix();
}

Matrix4f Node::view_matrix(){
    Matrix4f world_m= world_matrix().matrix();
    return get_camera_view()*world_m;
}

Affine3f Node::object_matrix_inverse(){
    return
            Translation<float,3>(-anchor)*
            Scaling(dimensions.cwiseProduct(scale))*
            rotation.inverse()*
            Translation<float,3>(-position);
}

Affine3f Node::world_matrix_inverse(){
    return
            Translation<float,3>(-anchor)*
            Scaling(Vector3f(1./ Array3f(dimensions.cwiseProduct(scale))))*
            rotation.inverse()*
            Translation<float,3>(-position)*
            (parent? parent->world_matrix_inverse():Affine3f::Identity());

}

Matrix4f Node::view_matrix_inverse(){
    return world_matrix_inverse().matrix()*get_camera_inverse_view();
}

Matrix4f Node::object_normal_matrix(){return object_matrix_inverse().matrix().transpose();}

Matrix4f Node::world_normal_matrix(){return world_matrix_inverse().matrix().transpose();}

Matrix4f Node::view_normal_matrix(){return view_matrix_inverse().matrix().transpose();}

Vector3f Node::screen_to_local(Vector3f p){
    Vector4f pos(p[0],p[1],p[2],1.0);
    pos  = max(pos,Vector4f(-1,-1,-1,-1));
    pos  = min(pos,Vector4f(1,1,1,1));
    Matrix4f m =Camera::get_main_camera()->projection_matrix*Camera::get_main_camera()->matrix;
    Matrix4f i=m.inverse();
    pos=i*Vector4f(pos);
    pos/=pos[3];
        return world_to_local(pos.head<3>());
    }
    Vector3f Node::world_to_local(Vector3f p){
        Vector4f pos(p[0],p[1],p[2],1.0);
        Matrix4f i =world_matrix_inverse().matrix();
        pos=i*pos;
        pos/=pos[3];
        return pos.head<3>();
    }
    Vector3f Node::parent_to_local(Vector3f p){
        Vector4f pos(p[0],p[1],p[2],1.0);
        pos=object_matrix_inverse()*pos;
        return pos.head<3>()/=pos[3];
    }

};
